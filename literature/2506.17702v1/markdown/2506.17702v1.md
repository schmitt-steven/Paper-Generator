## **Lower Bounds for Conjunctive Query Evaluation**

STEFAN MENGEL, Univ. Artois, CNRS, Centre de Recherche en Informatique de Lens (CRIL), France


In this tutorial, we will survey known results on the complexity of conjunctive query evaluation in different
settings, ranging from Boolean queries over counting to more complex models like enumeration and direct
access. A particular focus will be on showing how different relatively recent hypotheses from complexity
theory connect to query answering and allow showing that known algorithms in several cases can likely not
be improved.


CCS Concepts: â€¢ **Theory of computation** â†’ **Database theory** .


Additional Key Words and Phrases: todo


**1** **INTRODUCTION**


Understanding the complexity of different forms of query answering is one of the major research
areas in database theory. Historically, the complexity of queries has been studied in three ways: in
combined complexity, in data complexity [ 75 ], or in parameterized complexity [ 47 ]. When trying
to understand the necessary runtime to answer queries, combined complexity is very pessimistic:
since the query and the database are both the inputs, answering first-order queries is PSPACEhard and even conjunctive queries are NP-hard [ 29 ]. On the other end of the spectrum, in data
complexity all first-order queries are classified as in PTIME and thus easy [ 75 ], which blurs the
different complexities of different queries. So in a sense, both of these classical approaches are not
completely satisfying when trying to assess the hardness of concrete queries.
A more refined approach is parameterized complexity [ 47 ]: similarly to data complexity, one
considers the database as the main input, but instead of neglecting the query completely, one sees
its size as a parameter. The runtime dependence on the parameter may be bad, but crucially it
should not appear in the exponent of the input size, so roughly, for parameter _ğ‘˜_ and input size
_ğ‘›_, a runtime of 2 _[ğ‘˜]_ _ğ‘›_ is good, but _ğ‘›_ _[ğ‘˜]_ is bad. Parameterized complexity has led to many interesting
results on the complexity of query answering, in particular the characterization of all _classes_
of conjunctive queries that can be solved efficiently from the perspective of parameterized and
combined complexity [ 48, 49 ]. However, despite these merits, parameterized complexity has inherent
limitations: it is only applicable to _classes_ of queries, and thus we cannot use it to learn something
about the complexity of specific, concrete queries.
Fine-grained complexity opens up the possibility of attacking this question and determining the
exact exponents of optimal query answering algorithms for individual queries. The idea of the area
is to develop a complexity theory for problems inside PTIME to determine optimal runtimes for
problems that are in classical theory all considered easy. The goal is to complement problems with
algorithms that have runtime _ğ‘‚_ ( _ğ‘›_ _[ğ‘]_ ) with lower bounds that rule out any algorithm with runtime
_ğ‘‚_ ( _ğ‘›_ _[ğ‘]_ [âˆ’] _[ğœ€]_ ) for all _ğœ€_ _>_ 0.
Of course, with todayâ€™s techniques, one cannot expect to show unconditional lower bounds.
Also, it turns out that common classical assumptions like P â‰  NP or even the Exponential Time
Hypothesis, which plays a major role in parameterized complexity, appear to not be sufficient.
Instead, fine-grained complexity relies on its own set of different hypotheses. Often these posit
that known algorithms for important problems that have, despite considerable efforts, not been
improved for a long time, are optimal. So the results of fine-grained complexity theory are generally
of the form â€œIf there is no better algorithm for problem X, then there is no better algorithms for
problem Y, either.â€ where X can be one of several different, well-studied problems and _ğ‘Œ_ is the


Authorâ€™s address: Stefan Mengel, Univ. Artois, CNRS, Centre de Recherche en Informatique de Lens (CRIL), Lens, France,
mengel@cril.fr.




2 Stefan Mengel


problem that one is interested in. This makes fine-grained complexity a less coherent theory than,
say, the theory of NP-completeness, and the confidence in its main hypotheses is certainly lower.
However, it still provides techniques to give insights into which runtimes improvements would
imply major, surprising algorithmic advances on well-known problems.
This paper is _not_ a survey of or introduction to fine-grained complexity itselfâ€”there are certainly
others better qualified to do so [1] and this type of work already exists, see e.g. [ 78 ] or the videos
from a recent Simons Institute workshop that explain the area to a database theory audience [ 42 ].
Instead, this paper will be limited to a single question: how can fine-grained complexity be used to
determine the complexity of conjunctive query answering. Here query answering is not restricted
to materializing the complete query result or solving Boolean queries, but also covers tasks like
counting (as a prototypical aggregation task), enumeration and direct access. A large part of this
paper will be on linear time bounds, as this is the case that is by far most studied. As we will see,
there is a wealth of results on this. Afterwards, we will turn to super-linear runtimes. Unfortunately,
lower bounds for this case are far less developed, but we will give an overview of what is known
and which techniques exist. Throughout the whole paper, we will introduce important hypotheses
from fine-grained complexity that have been proven useful in database theory and show how they
have been applied.


_Acknowledgements._ This paper was written to complement a tutorial that the author was invited
to give at PODS 2025. The authors thanks the program committee for this opportunity to collect
and present the results surveyed in this paper.
Florent Capelli and Christoph Berkholz provided thoughtful comments, advice and discussion
on an earlier version of this paper. The author is grateful for the time and effort they invested into
this, which greatly improved the presentation of this survey.


**2** **PRELIMINARIES**


**2.1** **Database Queries**


We assume that the reader is familiar with the basics of database theory, in particular the relational
model, see e.g. the first part of [ 9 ]. In this paper, we will focus only on _conjunctive queries_, so queries
of the form _ğ‘_ ( _ğ‘‹_ ) :âˆ’ _ğ‘…_ 1 ( _ğ‘‹_ 1 ) _, . . ., ğ‘…_ _â„“_ ( _ğ‘‹_ _â„“_ ), where _ğ‘‹_ and the _ğ‘‹_ _ğ‘–_ are sets of variables with _ğ‘‹_ âŠ† [ï¿½] _ğ‘–_ âˆˆ[ _â„“_ ] _[ğ‘‹]_ _ğ‘–_ [.]
If _ğ‘‹_ = [ï¿½] _ğ‘–_ âˆˆ[ _â„“_ ] _[ğ‘‹]_ _ğ‘–_ [, then we call] _[ ğ‘]_ [a] _[ join query]_ [. If] _[ ğ‘‹]_ [=][ âˆ…] [, we call] _[ ğ‘]_ _[Boolean]_ [. If all relation symbols] _[ ğ‘…]_ _ğ‘–_
in _ğ‘_ are different, we say that _ğ‘_ is _self-join free_ ; if the same relation symbol repeats, we say that _ğ‘_
has self-joins. We assume basic familiarity with the AGM-bound [ 10 ] and worst-case optimal join
algorithms [ 65 ], see also [ 9, Chapters 27 and 28]. However, these concepts will not be central, and
knowledge of their existence will be enough.
As is standard, we assign hypergraphs to queries: for the query _ğ‘_ ( _ğ‘‹_ ) :âˆ’ _ğ‘…_ 1 ( _ğ‘‹_ 1 ) _, . . ., ğ‘…_ _â„“_ ( _ğ‘‹_ _â„“_ ), the
corresponding hypergraph _ğ»_ = ( _ğ‘‰, ğ¸_ ) has vertices _ğ‘‰_ : = [ï¿½] _ğ‘–_ âˆˆ[ _â„“_ ] _[ğ‘‹]_ _ğ‘–_ [and the edge set] [ {] _[ğ‘‹]_ _ğ‘–_ [|] _[ ğ‘–]_ [âˆˆ[] _[â„“]_ []}] [. A]
hypergraph _ğ»_ = ( _ğ‘‰, ğ¸_ ) is called _acyclic_ if the following process ends with a hypergraph with no
vertices or edges: while possible, delete a vertex that is contained in at most one edge, or delete
an edge that is a subset of another edge. A conjunctive query is called acyclic if its hypergraph is
acyclic. Acyclic queries are important and well studied because of their good algorithmic properties,
see e.g. [ 9, Chapters 20 and 21]. For background and many properties of acyclic hypergraphs,
see [ 13, 14, 20 ]. We say that a hypergraph is _â„_ _-uniform_ for some _â„_ âˆˆ N if all of its edges have size _â„_ .
All runtimes for query answering that we give will be for fixed queries and thus have no
dependence on the size of the query (but will of course depend on the actual query; we want


1 For example, there will be a keynote by Virginia Vassilevska Williams on this topic at PODS this year.




Lower Bounds for Conjunctive Query Evaluation 3


to differentiate hard queries from easy ones after all). We generally denote the size of the input
database, i.e. the overall number of tuples, by _ğ‘š_ while _ğ‘›_ is generally used for the size of the domain.


**2.2** **Fine-Grained Complexity**

As said in the introduction, fine-grained complexity is concerned with finding the optimal exact
exponent of runtime bounds for problems that can be solved in polynomial time. The considered
machine model are standard random access machines with logarithmic word-size and unit cost
operations, see e.g. [45] for a detailed discussion of this model.
We will mostly be interested in lower bounds saying that for a constant _ğ‘_ there is no _ğœ€_ _>_ 0
such that a problem can be solved in time _ğ‘‚_ ( _ğ‘›_ _[ğ‘]_ [âˆ’] _[ğœ€]_ ) . These lower bounds will be based on different
hypotheses which we will introduce throughout the paper. Since we mostly ignore sub-polynomial
factors, we will give most runtime bounds in _ğ‘‚_ [Ëœ] -notation, which is analogous _ğ‘‚_ -notation, but
ignores factors of the form _ğ‘›_ _[ğ‘œ]_ [(][1][)][ 2]

While we will not see this here, many algorithms and reductions in fine-grained complexity are
randomized, and they might fail with a probability _ğ‘_ _<_ [1] 2 [. The probability] _[ ğ‘]_ [can be decreased in a]

standard fashion by repeatedly running the algorithm. All our reductions here will be deterministic,
but it is still good to keep randomization in mind when reading papers in fine-grained complexity.
In particular, all hypotheses we mention here are in general also made in this randomized model,
sometimes without mentioning it explicitly.


**2.3** **The Complexity of Matrix Multiplication**


Fast matrix multipliation is one of the work horses of efficient algorithms in fine-grained complexity,
and it also increasingly plays a major role in query evaluation [ 8, 50, 58 ]. So let us discuss this basic
operation a little.
With the naive algorithm, one can multiply two _ğ‘›_ Ã— _ğ‘›_ -matrices in time _ğ‘‚_ ( _ğ‘›_ [3] ), which was thought
to be optimal until the breakthrough work of Strassen [ 72 ], showing that the problem has a subcubic algorithm. Since then there has been a race to improve the runtime bounds. The decisive
quantity here is the _matrix multiplication exponent ğœ”_ which is the smallest real number such that
there is an algorithm that computes the product of two _ğ‘›_ Ã— _ğ‘›_ -matrices with _ğ‘›_ _[ğœ”]_ [+] _[ğ‘œ]_ [(][1][)] operations [3] .
From Strassenâ€™s algorithm and the fact that we need to compute _ğ‘›_ [2] entries of the output, it follows
that 2 â‰¤ _ğœ”_ _<_ 3 and, while the exact number is not known, there have been regular improvements
of the upper bound in recent years, the current record being _ğœ”_ _<_ 2 _._ 371339 [5].
The best known lower bound for matrix multiplication is quadratic in _ğ‘›_ [ 17 ], and it does not
seem to be a widely held assumption that _ğœ”_ _>_ 2. In fact, many works introducing algorithms that
use matrix multiplication as a sub-routine and whose runtime thus depends on _ğœ”_ in more or less
complicated ways, also give resulting runtimes for the case _ğœ”_ = 2. That said, while there has been
steady progress over decades since [ 72 ], it appears likely that we are far away from determining _ğœ”_ .
We will mostly be concerned with _Boolean matrix multiplication_, i.e. matrix multiplication over
the Boolean semi-ring where, given two input matrices _ğ´_ = ( _ğ‘_ _ğ‘–ğ‘—_ ), _ğµ_ = ( _ğ‘_ _ğ‘–ğ‘—_ ), both from { 0 _,_ 1 } _[ğ‘›]_ [Ã—] _[ğ‘›]_ we
want to compute the matrix _ğ¶_ = ( _ğ‘_ _ğ‘–ğ‘—_ ) with _ğ‘_ _ğ‘–ğ‘—_ : = [ï¿½] _ğ‘˜_ âˆˆ[ _ğ‘›_ ] _[ğ‘]_ _ğ‘–ğ‘˜_ [âˆ§] _[ğ‘]_ _ğ‘˜ğ‘—_ [. So far, the best algorithms for]
Boolean matrix multiplication in fact use multiplication over the reals: given _ğ´_ and _ğµ_, interpret their
entries as real numbers and multiply them over the reals. Then, it is easy to see that substituting


2 In the literature, Ëœ _ğ‘‚_ often only ignores polylogarithmic instead of subpolynomial factors. However, since in fine-grained
complexity one generally ignores all subpolynomial factors, our slightly more liberal definition will be more convenient.
3 Note the following slight subtlety: _ğœ”_ is defined as a limit, and it is known that there is no single algorithm that attains
this limit [ 31 ]. So whatever the value of _ğœ”_ is, there is no algorithm with runtime _ğ‘‚_ ( _ğ‘›_ _[ğœ”]_ ) . However, since we will use our
version of the _ğ‘‚_ [Ëœ] -notation that does not take into account factors of the form _ğ‘›_ _[ğ‘œ]_ [(][1][)], we ignore this fact in the remainder of
this paper.




4 Stefan Mengel


any non-zero entry of the output _ğ¶_ by 1 gives the result of Boolean matrix multiplication. Note that
the runtime of this approach is _ğ‘‚_ [Ëœ] ( _ğ‘›_ _[ğœ”]_ ), so the same as that of non-Boolean matrix multiplication.
Of particular interest to us is a setting often called _sparse_ Boolean matrix multiplication where
the runtime is not measured in the dimension _ğ‘›_ but in the number _ğ‘š_ of non-zero entries of the
input and output. Note that if there is an algorithm of runtime _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) then _ğœ”_ = 2. However, the
other way round, even if _ğœ”_ = 2, it does not follow that sparse matrix multiplication has a (near)linear-time algorithm, since the input and output can have far less than _ğ‘›_ [2] non-zero entries. In that
case, algorithms for dense matrix multiplication and _ğœ”_ = 2 are not obviously helpful. That said,
there are several algorithms for sparse matrix multiplication that use algorithms for dense matrix
multiplication in more subtle ways: the current best runtime is an algorithm for sparse Boolean
matrix multiplication with runtime _ğ‘‚_ ( _ğ‘š_ [1] _[.]_ [3459] ) which in case _ğœ”_ = 2 is even _ğ‘‚_ ( _ğ‘š_ [4][/][3][+] _[ğœ€]_ ) for every
_ğœ€_ _>_ 0 [ 2 ]. The general belief in fine-grained complexity is that _ğ‘‚_ ( _ğ‘š_ [4][/][3] ) can likely not be beaten as
a runtime, see again [ 2 ], and that in particular there is no linear-time algorithm for sparse Boolean
matrix multiplication.


Hypothesis 1 ( _Sparse Boolean Matrix Multiplication Hypothesis_ ). _There is no algorithm that_
_solves sparse Boolean matrix multiplication in time_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) _._


**3** **UNDERSTANDING LINEAR-TIME QUERY ANSWERING**


In this section, we will turn to the complexity of different query answering problems. Since the case
of (nearly) linear time is the best understood, we will focus on understanding it first. In Section 4,
we will turn to the less well understood superlinear case. We will start our considerations with
Boolean queries before considering more complex questions like enumeration, counting and direct
access in later subsections.


**3.1** **Boolean Queries**

We first consider Boolean queries, since any lower bound that we can show for them will in
particular also give us lower bounds for other question like counting or enumeration. It will turn
out that in this whole section, acyclic queries will play a major role, due to the following classical
result by Yannakakis [79].


Theorem 3.1. _For every acyclic Boolean conjunctive query_ _ğ‘_ _there is an algorithm, given a data-_
_base ğ·_ _decides in linear time if ğ‘_ _it true on ğ·._


For a streamlined proof of Theorem 3.1, see [ 9, Chapter 21]. In the remainder of this subsection,
we will explain why acyclic queries are likely the _only_ Boolean queries that can be solved in linear
time and which hypotheses from fine-grained complexity suggest this.


_3.1.1_ _Graphlike Queries._ It will be useful to first consider the case in which all atoms have arity
two, so where the hypergraph of the query is a graph. Acyclicity of the query is then simply the
usual notion of acyclicity of graphs, so the absence of any cycles.
We want to make it plausible that cyclic graphlike queries cannot be solved in linear time, so
it appears useful to first consider queries that consist only of a single cycle and, to make things
even easier, we for now consider only the triangle query which has been studied extensively in the
database literature, see e.g. the pointers in [65]. We write it here as


_ğ‘_ [â–³] () :âˆ’ _ğ‘…_ 1 ( _ğ‘¥,ğ‘¦_ ) _, ğ‘…_ 2 ( _ğ‘¦,ğ‘§_ ) _, ğ‘…_ 3 ( _ğ‘§,ğ‘¥_ ) _._


What can we say about the complexity of _ğ‘_ [â–³] ? First, if we consider the corresponding join query


_ğ‘_ Â¯ [â–³] ( _ğ‘¥,ğ‘¦,ğ‘§_ ) :âˆ’ _ğ‘…_ 1 ( _ğ‘¥,ğ‘¦_ ) _, ğ‘…_ 2 ( _ğ‘¦,ğ‘§_ ) _, ğ‘…_ 3 ( _ğ‘§,ğ‘¥_ ) _,_




Lower Bounds for Conjunctive Query Evaluation 5


then we see by applying the celebrated AGM-bound [ 10 ] that | _ğ‘_ Â¯( _ğ·_ )| â‰¤ _ğ‘š_ [3][/][2] for any database of
_ğ‘‚_ size Ëœ ( _ğ‘š ğ‘š_ [3][/][2], and using a worst-case optimal join algorithm [ ) . So in particular, _ğ‘_ [â–³] can be solved in time Ëœ _ğ‘‚_ ( _ğ‘š_ [3] 65 [/][2] ) ], we can compute all answers in time . But can we do better? For Â¯ _ğ‘_ [â–³] we can
certainly not: the AGM-bound is tight, so there are inputs with Î©( _ğ‘š_ [3][/][2] ) output tuples, and since
we have to return them all, we cannot do so in time _ğ‘š_ [3][/][2][âˆ’] _[ğœ€]_ for any _ğœ€_ _>_ 0. However, if we only want
to know if there is an answer, we can use matrix multiplication to speed up query answering, as
shown by Alon, Yuster and Zwick [ 6 ]. Since the proof if short but quite instructive, we give it here.


Theorem 3.2. _If there is an algorithm for Boolean matrix multiplication of_ _ğ‘›_ Ã— _ğ‘›_ _-matrices with_
2 _ğœ”_
_runtime_ _ğ‘‚_ [Ëœ] ( _ğ‘›_ _[ğœ”]_ ) _, then there is an algorithm that answers ğ‘_ [â–³] _on inputs of size ğ‘š_ _in time_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ _ğœ”_ +1 ) _._


Proof. We use a technique based on degree splits. To this end, define the degree of an element
of the active domain as the number of tuples in which it appears in the input database. Then we
_ğœ”_ âˆ’1
call a domain element light if it has degree at most Î” : = _ğ‘š_ _ğœ”_ +1 and heavy otherwise. We will first
show how to detect answers of Â¯ _ğ‘_ [â–³] that contain a light element, say, for the variable _ğ‘¦_ . To do so,
we first compute the answers of _ğ‘_ _ğ‘¦_ ( _ğ‘¥,ğ‘¦,ğ‘§_ ) :âˆ’ _ğ‘…_ 1 ( _ğ‘¥,ğ‘¦_ ) _, ğ‘…_ 2 ( _ğ‘¦,ğ‘§_ ) in which _ğ‘¦_ takes a light element. We
can do this by first filtering out all heavy elements at the position of _ğ‘¦_ in the relations _ğ‘…_ 1 and _ğ‘…_ 2,
then we take all remaining tuples in _ğ‘…_ 1 and extend them in the up to Î” ways to _ğ‘§_ . Certainly, this
can be done in time _ğ‘‚_ [Ëœ] ( _ğ‘š_ Î”) . In the final step, we can filter with the relation _ğ‘…_ 3 to check if any of
the candidates thus computed is an answer to Â¯ _ğ‘_ [â–³] . Analogously, we can check if there is an answer
to Â¯ _ğ‘_ [â–³] that takes a light value in _ğ‘¥_ or _ğ‘§_ .
It remains to check for answers that only contain heavy values. There are at most _ğ‘š_ /Î” such
values and we can compute them efficiently, so we only have to show how to solve _ğ‘_ [â–³] on a database
with up to _ğ‘›_ [â€²] : = _ğ‘š_ /Î” domain elements. So let _ğ‘…_ 1 [â€²] [and] _[ ğ‘…]_ 2 [â€²] [be the relations we get from] _[ ğ‘…]_ [1] [ and] _[ ğ‘…]_ [2] [,]
respectively, by restriction to heavy values. We first solve the query _ğ‘_ [â€²] ( _ğ‘¥,ğ‘§_ ) :âˆ’ _ğ‘…_ 1 [â€²] [(] _[ğ‘¥,ğ‘¦]_ [)] _[, ğ‘…]_ 2 [â€²] [(] _[ğ‘¦,ğ‘§]_ [)] [ by]
matrix multiplication: let _ğ´_ be the adjacency matrix of _ğ‘…_ 1 [â€²] [, so the Boolean] _[ ğ‘›]_ [â€²] [ Ã—] _[ ğ‘›]_ [â€²] [-matrix indexed]
by the active domain which contains a 1 in an position ( _ğ‘,ğ‘_ ) if and only if ( _ğ‘,ğ‘_ ) âˆˆ _ğ‘…_ 1 [â€²] [. Define] _[ ğµ]_
analogously as the adjacency matrix of _ğ‘…_ 2 [â€²] [. Let] _[ ğ¶]_ [be the result of Boolean matrix multiplication of]
_ğ´_ and _ğµ_, then _ğ¶_ is the adjacency matrix of the relation containing the answers to _ğ‘_ [â€²] and thus we
can read off the answers directly from _ğ¶_ . Filtering by _ğ‘…_ 3 again, lets us check if _ğ‘_ [â–³] has an answer.
2 _ğœ”_
Ëœ The overall runtime of the algorithm is _ğœ”_ 2 _ğœ”_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ Î”) = _ğ‘‚_ [Ëœ] ( _ğ‘š_ _ğœ”_ +1 ) for the first part of the algorithm and
_ğ‘‚_ ( _ğ‘›_ [â€²] _[ğœ”]_ ) = Ëœ _ğ‘‚_ ( [ï¿½] _[ğ‘š]_ Î” ï¿½ ) = Ëœ _ğ‘‚_ ( _ğ‘š_ _ğœ”_ +1 ) for the second part, which gives the desired runtime bound. 

For _ğœ”_ _>_ 0, the mapping _ğœ”_ â†¦â†’ _ğœ”_ 2 _ğœ”_ +1 [is monotone and increasing in] _[ ğœ”]_ [, so better matrix multiplication]
4
algorithms give better algorithms for the triangle query. If _ğœ”_ = 2, then the runtime is _ğ‘‚_ [Ëœ] ( _ğ‘š_ 3 ) . Despite
intense research, there is no known better algorithm for triangle finding in graphs than that from
Theorem 3.2, which motivates the following common hypothesis found e.g. in [4].


Hypothesis 2 ( _Triangle Hypothesis_ ). _There is no algorithm that, given an input graph_ _ğº_ _with_ _ğ‘š_
_edges, decides in time_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) _if ğº_ _contains a triangle._


A common more concrete lower bound conjecture for triangle finding is Î©( _ğ‘š_ [4][/][3] ), which, as we
have seen, is tight in case _ğœ”_ = 2.
For conjunctive query answering, we get the following result.


Proposition 3.3. _Let_ _ğ‘_ _be cyclic self-join free Boolean conjunctive query in which all relations have_
_arity_ 2 _. Then, assuming the Triangle Hypothesis, there is no algorithm that, given a database_ _ğ·_ _of size_
_ğ‘š, decides ğ‘_ _on ğ·_ _in time_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) _._


Proof. We reduce from triangle finding, so let _ğº_ = ( _ğ‘‰, ğ¸_ ) be the input graph. We construct a
database _ğ·_ with active domain _ğ‘‰_ âˆª{ _ğ‘‘_ } where _ğ‘‘_ is a dummy element not in _ğ‘‰_ . Fix an induced cycle




6 Stefan Mengel


in the graph of the query _ğ‘_, which exists because _ğ‘_ is cyclic. Let _ğ‘…_ 1 ( _ğ‘¥_ 1 _,ğ‘¥_ 2 ), _ğ‘…_ 2 ( _ğ‘¥_ 3 _,ğ‘¥_ 4 ), _ğ‘…_ 3 ( _ğ‘¥_ 5 _,ğ‘¥_ 6 ) be
different atoms on the cycle, which might overlap in their endpoints. We set all _ğ‘…_ 1 _[ğ·]_ [=] _[ ğ‘…]_ 2 _[ğ·]_ [=] _[ ğ‘…]_ 3 _[ğ·]_ [=] _[ ğ¸]_
and all other relations for the atoms on the cycle to the equality relation on _ğ‘‰_ . For all relations
_ğ‘…_ ( _ğ‘¥_ _ğ‘—_ _,ğ‘¦_ ) where _ğ‘¥_ _ğ‘—_ is on the cycle and _ğ‘¦_ is not, we set _ğ‘…_ _[ğ·]_ : = _ğ‘‰_ Ã— { _ğ‘‘_ } and proceed analogously for
the atoms _ğ‘…_ _ğ‘–_ ( _ğ‘¦,ğ‘¥_ _ğ‘—_ ) . Finally, for all atoms _ğ‘…_ ( _ğ‘¦_ 1 _,ğ‘¦_ 2 ) where neither _ğ‘¦_ 1 nor _ğ‘¦_ 2 is on the cycle, we set
the input relation to { _ğ‘‘_ } [2] .
Clearly, _ğ·_ |= _ğ‘_ if and only if _ğº_ has a triangle, so the claim follows directly.  

_3.1.2_ _General Queries._ As we have seen in the last section, in the graph-like case, i.e. the case of
arity 2, having a cycle is the only cause for hardness of Boolean queries. In the general case, we
will now see another hard substructure.


_Example 3.4 (Loomis-Whitney Joins)._ The _ğ‘˜_ -dimensional Loomis-Whitney query is the query in
variables _ğ‘‹_ _ğ‘˜_ := { _ğ‘¥_ 1 _, . . .,ğ‘¥_ _ğ‘˜_ } defined by

_ğ‘_ _ğ‘˜_ _[ğ¿ğ‘Š]_ :âˆ’ ï¿½ _ğ‘…_ _ğ‘‹_ ( _ğ‘‹_ ) _._

_ğ‘‹_ âŠ† _ğ‘‹_ _ğ‘˜_ :| _ğ‘‹_ |= _ğ‘˜_ âˆ’1


Note that for _ğ‘˜_ _>_ 3 no Loomis-Whitney query contains an induced cycle, since all variable sets
of size at most _ğ‘˜_ âˆ’ 1 are contained in the scope of one atom. Moreover, it is known that any
1
Loomis-Whitney query can be answered in time _ğ‘‚_ [Ëœ] ( _ğ‘š_ [1][+] _ğ‘˜_ âˆ’1 ) [ 66 ] which for _ğ‘˜_ â‰¥ 5 is faster than the
state of the art for triangles.


We will next give evidence that the known algorithms for Loomis-Whitney queries might be
optimal, building on hypotheses from fine-grained complexity. To this end, define a hyperclique in
a _â„_ -uniform hypergraph _ğ»_ = ( _ğ‘‰, ğ¸_ ) be a set of vertices _ğ‘‰_ [â€²] âŠ† _ğ‘‰_ such that every set _ğ‘†_ âŠ† _ğ‘‰_ [â€²] of size _â„_
is contained in _ğ¸_ .


Hypothesis 3 ( _Hyperclique Hypothesis_ ). _For no pair_ _ğ‘˜_ _> â„_ _>_ 2 _of integers, there is an_ _ğœ–_ _>_ 0
_and an algorithm that, given a_ _â„_ _-uniform hypergraph_ _ğ»_ _with_ _ğ‘›_ _vertices, decides in time_ _ğ‘‚_ [Ëœ] ( _ğ‘›_ _[ğ‘˜]_ [âˆ’] _[ğœ€]_ ) _if_ _ğ»_
_contains a hyperclique of size ğ‘˜._


Note that the condition _â„_ _>_ 2 is necessary since for triangles and more general _ğ‘˜_ -cliques in graphs
there are algorithms with runtime _ğ‘‚_ ( _ğ‘›_ _[ğ‘ğ‘˜]_ ) for some _ğ‘_ _<_ 1 based on matrix multiplication [ 64 ], see
also Section 4.1. In contrast, despite intensive search, no such algorithms for hyperclique in _â„_ -regular
hypergraphs are known for any _â„_ _>_ 2. In particular, it is known that there is no generalization of
efficient matrix multiplication to higher order tensors that would allow adapting the algorithms
for _ğ‘˜_ -clique in a direct way [ 61 ]. Moreover, improving algorithms for hypercliques would give an
improvement for Max- _ğ‘˜_ -SAT [ 61 ], a problem that, in contrast to Max-2-SAT and _ğ‘˜_ -SAT, has so far
resisted all tries to improve upon the trivial runtime _ğ‘‚_ [Ëœ] (2 _[ğ‘›]_ ) for _ğ‘›_ -variable CNF-formulas.
Since Loomis-Whitney queries can be used to find cliques of size _ğ‘˜_ in ( _ğ‘˜_ âˆ’ 1 ) -regular hypergraphs,
we directly get the following lower bound that the algorithm from [66] is optimal.


Theorem 3.5. _Assuming the Hyperclique Hypothesis, for no_ _ğ‘˜_ _>_ 4 _and no_ _ğœ€_ _>_ 0 _, there is an_
1
_algorithm that, given an input databaseof size ğ‘š, decides ğ‘_ _ğ‘˜_ _[ğ¿ğ‘Š]_ _in time_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ [1][+] _ğ‘˜_ âˆ’1 [âˆ’] _[ğœ€]_ ) _._


Proof. Assume by way of contradiction that there are _ğ‘˜_ _>_ 4 and _ğœ€_ such that there is an
algorithm for _ğ‘_ _ğ‘˜_ _[ğ¿ğ‘Š]_ with the stated runtime. We will solve the hyperclique problem in ( _ğ‘˜_ âˆ’ 1 ) -regular
hypergraphs with the help of _ğ‘_ _ğ‘˜_ _[ğ¿ğ‘Š]_ . Let _ğ»_ = ( _ğ‘‰, ğ¸_ ) be a ( _ğ‘˜_ âˆ’ 1 ) -regular hypergraph. We define a
relation _ğ‘…_ that contains for all edges _ğ‘’_ âˆˆ _ğ¸_ all tuples we get by permutation of the elements in _ğ‘’_ .
Let _ğ‘…_ be the relation for every _ğ‘…_ _ğ‘‹_, then _ğ‘_ _ğ‘˜_ _[ğ¿ğ‘Š]_ is true on _ğ·_ if and only if _ğ»_ has a hyperclique of size _ğ‘˜_,
so _ğ‘_ _ğ‘˜_ _[ğ¿ğ‘Š]_ lets us find ( _ğ‘˜_ âˆ’ 1)-hypercliques, as desired.




Lower Bounds for Conjunctive Query Evaluation 7


Let _ğ‘›_ : = | _ğ‘‰_ |, then _ğ‘…_ has size at most _ğ‘›_ _[ğ‘˜]_ [âˆ’][1] . So overall, the runtime of the algorithm is at most
_ğ‘‚_ Ëœ _ğ‘›_ _ğ‘˜_ âˆ’1 ï¿½ 1+ _ğ‘˜_ âˆ’1 1 [âˆ’] _[ğœ€]_ [ï¿½] = _ğ‘‚_ [Ëœ] [ï¿½] _ğ‘›_ _[ğ‘˜]_ [âˆ’(] _[ğ‘˜]_ [âˆ’][1][)] _[ğœ€]_ [ï¿½], which contradicts the Hyperclique Hypothesis. ï¿½ï¿½


It follows easily that queries that contain Loomis-Whitney queries as subqueries cannot be
answered in linear time under reasonable assumptions. Interestingly, this yields a characterization
of all non-linear time queries due to the following result by Brault-Baron [19].


Theorem 3.6 ([ 19 ]). _Let_ _ğ»_ _be a hypergraph that is not acyclic. Then there is a set_ _ğ‘†_ _such that the_
_induced hypergraph_ _ğ»_ [ _ğ‘†_ ] _is a cycle or we can get a_ (| _ğ‘†_ | âˆ’ 1 ) _-uniform hyperclique from_ _ğ»_ [ _ğ‘†_ ] _by_
_deleting edges that are completely contained in other edges._


Brault-Baron inferred the following characterization of linear-time decidable Boolean queries.


Theorem 3.7. _Assume the Triangle Hypothesis and the Hyperclique Hypothesis. Then there is a_
_linear-time evaluation algorithm for a self-join free Boolean conjunctive query_ _ğ‘_ _if and only if_ _ğ‘_ _is_
_acyclic._


Proof sketch. For the upper bound, we use the Yannakakis algorithm of Theorem 3.1. For
the lower bound, we use Theorem 3.6 to embed triangle or hyperclique finding, similarly to
Proposition 3.3. 

**3.2** **Counting**


In this section, we consider the question of counting answers to conjunctive queries as a prototypical
aggregation question. In particular, we will show for which queries we can expect algorithms that
allow counting answers in linear time. Since any such algorithm allows in particular answering if
there is any answer, we get from Theorem 3.7 that for self-join free queries, we can restrict our
attention to acyclic queries. In the case of join queries, i.e. when all variables are output variables,
this already characterizes the linear-time solvable queries, since there is a generalization of the
Yannakakis algorithm, see e.g. [19, Lemma 19].


Theorem 3.8. _Assume the Triangle Hypothesis and the Hyperclique Hypothesis. Then there is a_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ )
_algorithm that counts the answers to a join query ğ‘_ _on instances of size ğ‘š_ _if and only if ğ‘_ _is acyclic._


Note that in Theorem 3.8 we do not require self-join freeness, since self-joins can be dealt with
in the lower bound with an interpolation argument first used in [35].
The situation becomes more interesting for queries with projections. Pichler and Skritek [ 69 ] were
the first to show that at least in _combined_ complexity projections make counting hard. Following
this, a line of work including [ 30, 37 â€“ 39, 46 ] lead to a good understanding of tractable classes of
queries, both in parameterized and combined complexity. The first results for fixed queries are
found in [ 37 ]. However, those only apply to runtimes that are at most cubic, so we present a variant
of the ideas from [37] here that is taken from the note [63].
We will need some more definitions: a dominating set _ğ‘†_ of a graph _ğº_ = ( _ğ‘‰, ğ¸_ ) is a set _ğ‘†_ âŠ† _ğ‘‰_ such
that every vertex not in _ğ‘†_ has a neighbor in _ğ‘†_ . The problem _ğ‘˜_ -Dominating Set (short _ğ‘˜_ -DS) is to
decide, given a graph _ğº_, if _ğº_ has a dominating set of size at most _ğ‘˜_ .
Our aim will be to show the following lower bound for the star queries that have already been a
crucial building block of the lower bounds in [38, 39].


Lemma 3.9. _Let ğ‘˜_ âˆˆ N _with ğ‘˜_ â‰¥ 2 _. If there is an algorithm that counts answers to_

_ğ‘_ _ğ‘˜_ _[â˜…]_ [(] _[ğ‘¥]_ [1] _[, . . .,ğ‘¥]_ _[ğ‘˜]_ [)][ :][âˆ’] ï¿½ _ğ‘…_ ( _ğ‘¥_ _ğ‘–_ _,ğ‘§_ )

_ğ‘–_ âˆˆ[ _ğ‘˜_ ]




8 Stefan Mengel


_in time_ _ğ‘‚_ ( _ğ‘š_ _[ğ‘˜]_ [âˆ’] _[ğœ€]_ ) _on databases with_ _ğ‘š_ _tuples for some_ _ğœ€_ _>_ 0 _, then there is a_ _ğ‘˜_ [â€²] âˆˆ N _,ğ‘˜_ [â€²] _>_ 3 _such that_
_ğ‘˜_ [â€²] _-DS can be decided in time ğ‘‚_ ( _ğ‘›_ _[ğ‘˜]_ [â€²] [âˆ’] _[ğœ–]_ ) _on graphs with ğ‘›_ _vertices._


The existence of an algorithm for _ğ‘˜_ -DS in Lemma 3.9 is very unlikely because it would contradict the Strong Exponential Time Hypothesis, a very impactful hypothesis from fine-grained
complexity [51, 52].


Hypothesis 4 ( _Strong Exponential Time Hypothesis_ ). _For every_ _ğœ€_ _>_ 0 _, there is a_ _ğ‘˜_ âˆˆ N _such_
_that ğ‘˜-SAT cannot be solved on instances with ğ‘›_ _variables in time_ _ğ‘‚_ [Ëœ] (2 _[ğ‘›]_ [(][1][âˆ’] _[ğœ€]_ [)] ) _._


SAT is certainly the most well-studied problem in complexity theory, and despite this effort and
the existence of faster algorithms for restricted variants like _ğ‘˜_ -SAT, no algorithm with a runtime
_ğ‘‚_ ( 2 _[ğ‘›]_ [(][1][âˆ’] _[ğœ€]_ [)] ) is known. This makes the Strong Exponential Time Hypothesis rather plausible. The
following connection is from [68].


Theorem 3.10. _Assuming the Strong Exponential Time Hypothesis, there is no constant_ _ğœ–_ [â€²] _such_
_that there is a constant_ _ğ‘˜_ _and an algorithm for_ _ğ‘˜_ _-DS with runtime_ _ğ‘‚_ ( _ğ‘›_ _[ğ‘˜]_ [âˆ’] _[ğœ€]_ [â€²] ) _on graphs with_ _ğ‘›_ _vertices._


We now return to our star queries.


Proof of Lemma 3.9. Choose _ğ‘˜_ [â€²] as a fixed integer such that _ğ‘˜_ [â€²] _> ğ‘˜_ [2] / _ğœ–_ and _ğ‘˜_ [â€²] is divisible by _ğ‘˜_ .
We will encode _ğ‘˜_ [â€²] -DS into the query _ğ‘_ _ğ‘˜_ _[â˜…]_ [. To this end, let] _[ ğº]_ [=][ (] _[ğ‘‰, ğ¸]_ [)][ be an input for] _[ ğ‘˜]_ [â€²] [-DS. Set]

_ğ‘…_ := {(ï¿½ _ğ‘¢, ğ‘£_ ) | _ğ‘£_ âˆˆ _ğ‘‰,_ ï¿½ _ğ‘¢_ = ( _ğ‘¢_ 1 _, . . .,ğ‘¢_ _ğ‘˜_ â€² / _ğ‘˜_ ) âˆˆ _ğ‘‰_ _[ğ‘˜]_ [â€²] [/] _[ğ‘˜]_ _,_ âˆ€ _ğ‘–_ âˆˆ[ _ğ‘˜_ [â€²] / _ğ‘˜_ ] : _ğ‘¢_ _ğ‘–_ _ğ‘£_ âˆ‰ _ğ¸,ğ‘¢_ _ğ‘–_ â‰  _ğ‘£_ } _._


Then any assignment ï¿½ _ğ‘¢_ [1] _, . . .,_ ï¿½ _ğ‘¢_ _[ğ‘˜]_ to _ğ‘¥_ 1 _, . . .,ğ‘¥_ _ğ‘˜_ corresponds to a choice _ğ‘†_ of at most _ğ‘˜_ [â€²] vertices in _ğº_ .
The set _ğ‘†_ is a dominating set if and only if there is no vertex _ğ‘£_ in _ğ‘‰_ that is not in _ğ‘†_ and has no
neighbor in _ğ‘†_ . This is the case if and only if there is no _ğ‘£_ âˆˆ _ğ‘‰_ that assigned to _ğ‘§_ makes _ğ‘_ _ğ‘˜_ _[â˜…]_ [true.]
Thus the answers to _ğ‘_ _ğ‘˜_ _[â˜…]_ [(] _[ğ‘¥]_ [1] _[, . . .,ğ‘¥]_ _[ğ‘˜]_ [)] [ are exactly the assignments] [ ï¿½] _[ğ‘¢]_ [1] _[, . . .,]_ [ ï¿½] _[ğ‘¢]_ _[ğ‘˜]_ [that do] _[ not]_ [ correspond to]
dominating sets of size at most _ğ‘˜_ [â€²] in _ğº_ . Since there are exactly _ğ‘›_ _[ğ‘˜]_ [â€²] choices for the ï¿½ _ğ‘¢_ _ğ‘–_, any algorithm
counting the answers to _ğ‘_ _ğ‘˜_ _[â˜…]_ [(] _[ğ‘¥]_ [1] _[, . . .,ğ‘¥]_ _[ğ‘˜]_ [)][ directly yields an algorithm for] _[ ğ‘˜]_ [â€²] [-DS.]
We now analyze the runtime of the above algorithm. Note that the time for the construction of _ğ‘…_
is negligible, so the runtime is essentially that of the counting algorithm for _ğ‘_ _ğ‘˜_ _[â˜…]_ [(] _[ğ‘¥]_ [1] _[, . . .,ğ‘¥]_ _[ğ‘˜]_ [)] [. First]



_ğ‘˜_ [â€²]
observe that the relation _ğ‘…_ has at most _ğ‘›_ _ğ‘˜_



observe that the relation _ğ‘…_ has at most _ğ‘›_ _ğ‘˜_ [+][1] tuples. The exponent of the runtime of the counting

algorithm is thus

_ğ‘˜_ â€²

( _ğ‘˜_ âˆ’ _ğœ–_ ) = _ğ‘˜_ [â€²] + _ğ‘˜_ âˆ’ _[ğ‘˜]_ [â€²] _[ğœ–]_ âˆ’ _ğœ–_ _< ğ‘˜_ [â€²] + _ğ‘˜_ âˆ’ _[ğ‘˜]_ [2] _[ğœ–]_

ï¿½ _ğ‘˜_ [+][ 1] ï¿½ _ğ‘˜_ _ğœ–ğ‘˜_ [âˆ’] _[ğœ–]_ [=] _[ ğ‘˜]_ [â€²] [ âˆ’] _[ğœ–]_


where the inequality comes from the choice of _ğ‘˜_ [â€²] satisfying _ğ‘˜_ [â€²] _> ğ‘˜_ [2] / _ğœ–_ . 

Corollary 3.11. _If SAT has no algorithm with runtime_ _ğ‘‚_ ( 2 _[ğ‘›]_ [(][1][âˆ’] _[ğœ–]_ [)] ) _for any_ _ğœ–_ _>_ 0 _, then there is no_
_constant ğ‘˜_ âˆˆ N _, ğ‘˜_ â‰¥ 2 _and no ğœ–_ [â€²] _>_ 0 _such that there is an algorithm that counts answers to_

_ğ‘_ _ğ‘˜_ _[â˜…]_ [(] _[ğ‘¥]_ [1] _[, . . .,ğ‘¥]_ _[ğ‘˜]_ [)][ :][âˆ’] ï¿½ _ğ‘…_ ( _ğ‘¥_ _ğ‘–_ _,ğ‘§_ )

_ğ‘–_ âˆˆ[ _ğ‘˜_ ]


_in time ğ‘‚_ ( _ğ‘š_ _[ğ‘˜]_ [âˆ’] _[ğœ–]_ [â€²] ) _on databases with ğ‘š_ _tuples._


The queries _ğ‘_ _ğ‘˜_ _[â˜…]_ [are important because they can be embedded into many other queries. They thus]
play a crucial role in understanding the parameterized complexity of counting for conjunctive
queries, see e.g. [19, 37, 39]. One central notion that we need in our fine-grained setting is that of
free-connex acyclic queries, a concept from [ 12 ]. An acyclic conjunctive query with hypergraph H




[â€²] _[ğœ–]_

âˆ’ _ğœ–_ _< ğ‘˜_ [â€²] + _ğ‘˜_ âˆ’ _[ğ‘˜]_ [2] _[ğœ–]_
_ğ‘˜_ _ğœ–ğ‘˜_



â€²

( _ğ‘˜_ âˆ’ _ğœ–_ ) = _ğ‘˜_ [â€²] + _ğ‘˜_ âˆ’ _[ğ‘˜]_ [â€²] _[ğœ–]_
_ğ‘˜_ [+][ 1] ï¿½ _ğ‘˜_



_ğœ–ğ‘˜_ [âˆ’] _[ğœ–]_ [=] _[ ğ‘˜]_ [â€²] [ âˆ’] _[ğœ–]_




Lower Bounds for Conjunctive Query Evaluation 9


and free variables _ğ‘†_ is called _free-connex_ if the hypergraph H âˆª{ _ğ‘†_ } that we get from H by adding
_ğ‘†_ as an edge is acyclic as well. Non Free-connex queries are hard in the following sense.


Theorem 3.12. _Let_ _ğ‘_ _be a self-join free conjunctive query that is acyclic but not free-connex. Then,_
_assuming the Strong Exponential Time Hypothesis there is no algorithm that counts the solutions of_ _ğ‘_
_on a database with ğ‘š_ _tuples in time ğ‘‚_ ( _ğ‘š_ [2][âˆ’] _[ğœ–]_ [â€²] ) _for any ğœ–_ [â€²] _._


The argument is a minimal adaption of one found in the full version of [ 12 ] for enumeration [4] .
The idea is to embed the query _ğ‘_ _[â˜…]_ 2 [and then use Corollary 3.11. For the details, we refer to [63].]
From Theorem 3.12, we get the following dichotomy theorem for linear time counting.


Theorem 3.13. _Assume the Strong Exponential Time Hypothesis, the Triangle Hypothesis and the_
_Hyperclique Hypothesis. Then there is a_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) _algorithm that counts the answers to a self-join free_
_conjunctive query ğ‘_ _on instances of size ğ‘š_ _if and only if ğ‘_ _is free-connex acyclic._


Proof (sketch). The upper bound for Theorem 3.13 comes from the fact that for free-connex
acyclic queries, one can eliminate all projected variables efficiently (see the proof and the discussion
in [ 14, Section 4.1]), and then use the counting variant of the Yannakakis algorithm as in Theorem 3.8.
For the lower bound, if _ğ‘_ is cyclic, then by Theorem 3.7 we get a lower bound using the fact
that a counting algorithm also lets us decide the Boolean query we get from _ğ‘_ by projecting out all
variables. If _ğ‘_ is cyclic by not free-connex, the lower bound follows from Theorem 3.12. 

**3.3** **Enumeration**

We next turn to constant delay enumeration, which is the following problem: given a query and
a database, first, in the _preprocessing phase_, compute a data structure that is then used in the
_enumeration phase_ to print out the answers to the query one after the other without repetition.
There are two different time bounds in enumeration algorithms: first the bound on the preprocessing
phase and then the _delay_ which is the maximal allowed time between printing out two answers.
The most studied version in database theory is _constant delay enumeration_ where we want the
delay between answers to be independent of the database and depend only on the query, which
we consider fixed; this model has first been introduced in the very influential paper [ 12 ] and since
then studied extensively throughout database theory. Somewhat surprisingly, there are many query
evaluation problems which allow constant delay enumeration, see e.g. the survey [14].
Enumeration for conjunctive queries was already studied in [ 12 ], the first paper to study constant
delay enumeration, which might also have been the first in database theory to use fine-grained
complexity even before that field was well-established and without making an explicit connection.
For the case of join queries, similarly to counting, from a lower bound perspective nothing too
interesting happens: acyclic join queries allow constant delay enumeration after linear preprocessing [11] [5], and since an enumeration algorithm can in particular be used to decide if there are any
answers, we get from Theorem 3.7 that acyclicity is the only property that yields constant delay
after linear preprocessing (assuming the Triangle Hypothesis and the Hyperclique Hypothesis, of
course).


4 [Unfortunately, this full version has never been published in a journal, but it can be found at https://webusers.imj-](https://webusers.imj-prg.fr/~arnaud.durand/papers/BDGlongversion.pdf)
[prg.fr/~arnaud.durand/papers/BDGlongversion.pdf. The techniques can also be found in [11, Chapter 2.7].](https://webusers.imj-prg.fr/~arnaud.durand/papers/BDGlongversion.pdf)
5 The proof in [ 11 ] uses a translation of relational conjunctive queries to a fragment of functional first-order logic and then
works in that setting which makes the argument somewhat difficult to follow for the reader not used to that setting. There
are by now algorithms working directly on the relational database [ 19, Lemma 19] or using factorized representations [ 67 ].
For an accessible presentation see the tutorial [14].




10 Stefan Mengel


Theorem 3.14. _Assume the Triangle Hypothesis and the Hyperclique Hypothesis. Then there is an_
_enumeration algorithm for a self-join free join query_ _ğ‘_ _with preprocessing time_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) _and constant_
_delay on instances of size ğ‘š_ _if and only if ğ‘_ _is acyclic._


We remark that, for the lower bound, since we are only interested in the first enumerated solution,
we could instead go up to a linear delay bound and get the same statement.
The enumeration complexity of join queries with self-joins appears to be far harder to understand
than that of self-join free queries. It was first observed in [ 14 ] that the are cyclic join queries with
self-joins whose answers can be enumerated with constant delay after linear preprocessing. This
line of work was extended in [ 26 ], giving many more examples where this happens and some
more systematic understanding. Overall, the situation seems to be very subtle in the sense that
apparently minor variations in the queries can have a big impact on their complexity. The complexity
in that setting is thus not very well understood, and even for some concrete example queries, the
enumeration complexity is unknown. We will thus restrict to self-join free queries in the remainder
of this section.

Self-join free queries get more interesting in the case with projections. We will consider a self-join
free variant of the star queries we saw already in Section 3.2.

_ğ‘_ Â¯ _ğ‘˜_ _[â˜…]_ [(] _[ğ‘¥]_ [1] _[, . . .,ğ‘¥]_ _[ğ‘˜]_ [)][ :][âˆ’] ï¿½ _ğ‘…_ _ğ‘–_ ( _ğ‘¥_ _ğ‘–_ _,ğ‘§_ )

_ğ‘–_ âˆˆ[ _ğ‘˜_ ]


Theorem 3.15. _[_ _12_ _] Assuming the Sparse Boolean Matrix Multiplication Hypothesis, there is no_
_enumeration algorithm for_ Â¯ _ğ‘_ _[â˜…]_ 2 _[on instances of size][ ğ‘š]_ _[with preprocessing]_ [ Ëœ] _[ğ‘‚]_ [(] _[ğ‘š]_ [)] _[ and delay]_ [ Ëœ] _[ğ‘‚]_ [(][1][)] _[.]_


In [ 12 ] the complexity assumption is that (non-sparse) Boolean matrix multiplication cannot be
done in quadratic time, but the proof actually yields the stronger statement we give here.


Proof of Theorem 3.15. We will show how to use Â¯ _ğ‘_ _[â˜…]_ 2 [for Boolean matrix multiplication. So]
let _ğ´_ and _ğµ_ be matrices given as lists of indices ( _ğ‘–, ğ‘—_ ) of their at most _ğ‘š_ non-zero entries. We define a
database _ğ·_ for Â¯ _ğ‘_ _[â˜…]_ 2 [by setting] _[ ğ‘…]_ 1 _[ğ·]_ [:] [=] _[ ğ´]_ [and] _[ ğ‘…]_ 2 _[ğ·]_ [:] [=][ {(] _[ğ‘—,ğ‘–]_ [) | (] _[ğ‘–, ğ‘—]_ [) âˆˆ] _[ğµ]_ [}] [ (so the transpose of the matrix).]
Then Â¯ _ğ‘_ _[â˜…]_ 2 [(] _[ğ·]_ [)][ contains exactly the non-zero entries of the Boolean matrix product] _[ ğ´ğµ]_ [.]
Let _ğ‘š_ [â€²] be the maximal number of non-zero entries in _ğ´_, _ğµ_ and _ğ´ğµ_ . Assume by way of contradiction
that there is an enumeration algorithm with preprocessing _ğ‘‚_ ( _ğ‘š_ ) and delay _ğ‘‚_ [Ëœ] ( 1 ) . Then computing
_ğ‘‚_ all non-zero entries in Ëœ ( _ğ‘š_ [â€²] ) to enumerate the up to _ğ´ğµ_ using this algorithm as above takes time _ğ‘š_ [â€²] non-zero entries of _ğ´ğµ_ . So the overall runtime is _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) for the preprocessing and Ëœ _ğ‘‚_ ( _ğ‘š_ [â€²] ) which
contradicts the Sparse Boolean Matrix Multiplication Hypothesis. 

Now with the exact same embedding as mentioned for Theorem 3.12, we get the following.


Theorem 3.16. _Let_ _ğ‘_ _be a self-join free conjunctive query that is acyclic but not free-connex. Then,_
_assuming the Sparse Boolean Matrix Multiplication Hypothesis, there is no enumeration algorithm_
_for ğ‘_ _on a database with ğ‘š_ _tuples with preprocessing time_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) _and delay_ _ğ‘‚_ [Ëœ] (1) _._


Since free-connex acyclic queries have algorithms with preprocessing _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) and delay _ğ‘‚_ [Ëœ] ( 1 ) [ 12 ],
this directly yields the following characterization.


Theorem 3.17. _Assume the Triangle Hypothesis, the Hyperclique Hypothesis and the Sparse Boolean_
_Matrix Multiplication Hypothesis. Then there is an enumeration algorithm for a conjunctive query_ _ğ‘_
_with preprocessing time_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) _and delay_ _ğ‘‚_ [Ëœ] (1) _if and only if ğ‘_ _is free-connex acyclic._


There is much more to say about constant delay enumeration then we can do here, but since
much of it has been surveyed elsewhere, we refer the reader to [14, 70, 71].




Lower Bounds for Conjunctive Query Evaluation 11


**3.4** **Direct Access**


A restricted version of enumeration is _direct access_ where the aim is to simulate an array containing
the whole query result without necessarily materializing it. After preprocessing the input database
for a restricted time, in the _access phase_, given an integer _ğ‘–_, the algorithm must return the _ğ‘–_ th
element of the (simulated) array containing the query result; if there are less than _ğ‘–_ answers, the
algorithm must return an error. The time required to return an answer at the requested position _ğ‘–_
is called the _access time_ of the algorithm.
Clearly, direct access algorithms easily allow enumeration of the query result: after preprocessing,
simply request the outputs one after another in order by starting with _ğ‘–_ = 1 and incrementing until
there is an error because no answers are left. Since it is known that free-connex acyclic queries
allow direct access with logarithmic access time and linear preprocessing [ 19, 27 ], we directly get
the following characterization.


Theorem 3.18. _Assume the Triangle Hypothesis, the Hyperclique Hypothesis and the Sparse Boolean_
_Matrix Multiplication Hypothesis. Then there is a direct access algorithm for a self-join free conjunctive_
_query ğ‘_ _with preprocessing time_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) _and delay_ _ğ‘‚_ [Ëœ] (1) _if and only if ğ‘_ _is free-connex acyclic._


Theorem 3.18 does not specify the order in which the answers are stored in the simulated array.
However, it is natural to assume an order on the answers, which, as we will see, has great impact
on the the complexity of the problem. Many different ways of defining orders on query have been
studied see e.g. [ 7, 36, 73 ]; we will only consider two types of orders here: lexicographic orders and
orders given by sums of weights of domain values. We will discuss them in individual subsections
below.


_3.4.1_ _Lexicographic Orders._ One natural way of ordering query answers is by lexicographic orders.
To do so, we assume that there is an order â‰¼ on the active domain on the database. Then for every
order âª¯ of the variables of the query, we get an induced order on tuples: given distinct tuples _ğ‘_
and _ğ‘_, we let _ğ‘¥_ be the first variable in âª¯ on which _ğ‘_ and _ğ‘_ differ. Then we say _ğ‘_ â‰¤ _ğ‘_ if the entry on
position _ğ‘¥_ in _ğ‘_ is before that of _ğ‘_ w.r.t. â‰¼ . Note that the order on the tuples is different for different
variable orders.


_Example 3.19._ Let the active domain be { 0 _,_ 1 } with 0 â‰¼ 1. Consider a query _ğ‘_ ( _ğ‘¥,ğ‘¦_ ) and the query
result {( 0 _,_ 0 ) _,_ ( 0 _,_ 1 ) _,_ ( 1 _,_ 0 ) _,_ ( 1 _,_ 1 )} . If the variable order has _ğ‘¥_ âª¯ _ğ‘¦_, then the answers are sorted as
(0 _,_ 0) â‰¤(0 _,_ 1) â‰¤(1 _,_ 0) â‰¤(1 _,_ 1). If we have that _ğ‘¦_ âª¯ _ğ‘¥_, then (0 _,_ 0) â‰¤(1 _,_ 0) â‰¤(0 _,_ 1) â‰¤(1 _,_ 1).


It will be convenient to consider the _testing problem_ for conjunctive queries which is the following
for any fixed conjunctive query _ğ‘_ : given a database _ğ·_, after preprocessing _ğ·_ for a restricted time,
the algorithm has to answer, given a tuple _ğ‘_, if _ğ‘_ âˆˆ _ğ‘_ ( _ğ·_ ) . Again, we separate preprocessing time
and query time. Note that testing for join queries is always easy, since we only have to check if _ğ‘_
is consistent with the relations of all atoms of _ğ‘_ . On the other end of the spectrum, for Boolean
conjunctive queries, the only possible input _ğ‘_ is the empty assignment, so the testing problem is
equivalent to deciding Boolean queries. We will be interested in the middle ground where some
but not all variables are projected.
The following is useful for direct access lower bounds, see e.g. [ 22 ]. We denote by âˆ¥ _ğ·_ âˆ¥ the size
of a database _ğ·_ .


Lemma 3.20. _Let_ _ğ‘_ ( _ğ‘¥_ 1 _, . . .,ğ‘¥_ _ğ‘Ÿ_ ) :âˆ’ _ğ‘…_ 1 ( _ğ‘‹_ 1 ) âˆ§ _. . ._ âˆ§ _ğ‘…_ _â„“_ ( _ğ‘‹_ _â„“_ ) _be a join query and let_ _ğœ‹_ _be a variable order_
_for_ _ğ‘_ _. Let_ _ğ‘‹_ [â€²] _be a variable set consisting of a prefix of_ _ğœ‹_ _. Then, if there is a direct-access algorithm for_
_ğ‘_ ( _ğ‘¥_ 1 _, . . .,ğ‘¥_ _ğ‘˜_ ) _respecting the lexicographic order induced by_ _ğœ‹_ _with preprocessing time_ _ğ‘_ ( _ğ‘š_ ) _and access_
_time_ _ğ‘_ ( _ğ‘š_ ) _for databases of size_ _ğ‘š_ _, then there is a testing algorithm for the projected query_ _ğ‘_ ( _ğ‘‹_ [â€²] ) _with_




12 Stefan Mengel


_the same body with preprocessing time_ _ğ‘_ ( _ğ‘š_ ) _and access time_ _ğ‘‚_ [Ëœ] (log( _ğ‘€_ ( _ğ‘š_ )) _ğ‘_ ( _ğ‘š_ )) _where_ _ğ‘€_ ( _ğ‘š_ ) _is an_
_upper bound with ğ‘€_ ( _ğ‘š_ ) â‰¥ max _ğ·_ :âˆ¥ _ğ·_ âˆ¥â‰¤ _ğ‘š_ (| _ğ‘_ ( _ğ·_ )| | âˆ¥ _ğ·_ âˆ¥â‰¤ _ğ‘š_ ) _._


Proof. Since _ğ‘‹_ [â€²] contains the variables of a prefix, for every assignment _ğ‘_ to _ğ‘‹_ [â€²] all tuples
consistent with _ğ‘_ in _ğ‘_ ( _ğ·_ ) are in a contiguous block of the array simulated by the direct access
algorithm. Also, the order of those blocks is given by the lexicographic order on _ğ‘‹_ [â€²], so we can use
binary search to check if a non-empty block for a given assignment to _ğ‘‹_ [â€²] exists. This directly gives
the claimed runtime bound. 

Since we are interested in fixed conjunctive queries, we can bound log( _ğ‘€_ ( _ğ‘š_ )) â‰¤ _ğ‘‚_ (log( _ğ‘š_ )), so
we only lose a logarithmic factor when going from direct access to testing.
It turns out that understanding the query _ğ‘_ _[â˜…]_ 2 [is crucial to the understanding of lexicographic]
direct access due to the following lower bound.


Lemma 3.21. _Assuming the Triangle Hypothesis, there is no testing algorithm for_ _ğ‘_ _[â˜…]_ 2 _[with prepro-]_
_cessing time_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) _and testing time_ _ğ‘‚_ [Ëœ] (1) _on databases of size ğ‘š._


Proof. By way of contradiction, assume that an algorithm with preprocessing time _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) and
testing time _ğ‘‚_ [Ëœ] ( 1 ) exists. We use it to detect triangles in graphs as follows: given a graph _ğº_ = ( _ğ‘‰, ğ¸_ ),
construct a database _ğ·_ for _ğ‘_ _[â˜…]_ 2 [by setting] _[ ğ‘…]_ _[ğ·]_ [=] _[ ğ¸]_ [. Apply the preprocessing on] _[ ğ·]_ [. Afterwards, for]
every ( _ğ‘,ğ‘_ ) âˆˆ _ğ¸_ test if ( _ğ‘,ğ‘_ ) âˆˆ _ğ‘_ _[â˜…]_ 2 [(] _[ğ·]_ [)][. If there is such an edge, return true, otherwise false.]
The algorithm is correct, since there is an edge ( _ğ‘,ğ‘_ ) âˆˆ _ğ¸_ with ( _ğ‘,ğ‘_ ) âˆˆ _ğ‘_ _[â˜…]_ 2 [(] _[ğ·]_ [)] [ if and only if]
there is a triangle ( _ğ‘,ğ‘,ğ‘_ ) in _ğº_ . To bound the runtime, first observe that the preprocessing takes
time _ğ‘‚_ [Ëœ] (âˆ¥ _ğ·_ âˆ¥) = _ğ‘‚_ [Ëœ] (| _ğ¸_ |) . Then we make | _ğ¸_ | queries, each in time _ğ‘‚_ [Ëœ] ( 1 ) . So the overall runtime of the
algorithm is _ğ‘‚_ [Ëœ] (| _ğ¸_ |), which contradicts the Triangle Hypothesis. 

Embedding _ğ‘_ _[â˜…]_ 2 [, we get a version of Theorem 3.18 without the][ Sparse Boolean Matrix Multiplication]
Hypothesis, if we insist on lexicographic orders.


Corollary 3.22. _Assume the Triangle Hypothesis and the Hyperclique Hypothesis. Then there is a_
_ğ‘‚_ _direct access algorithm for a conjunctive query_ Ëœ ( _ğ‘š_ ) _and delay_ Ëœ _ğ‘‚_ (1) _if and only if ğ‘_ _is free-connex acyclic. ğ‘_ _for a lexicographic order with preprocessing time_


In the algorithm of Theorem 3.18 and Corollary 3.22, we cannot choose the lexicographic order of
the variables but it depends on the query. So a natural question is: can we choose any lexicographic
order and still get linear preprocessing for direct access? This question was answered negatively
in [27]. A crucial role is played by the following variant of _ğ‘_ _ğ‘˜_ _[â˜…]_ [:]

_ğ‘_ Ë† _ğ‘˜_ _[â˜…]_ [(] _[ğ‘¥]_ [1] _[, . . .,ğ‘¥]_ _[ğ‘˜]_ _[,ğ‘§]_ [)][ :][âˆ’] ï¿½ _ğ‘…_ ( _ğ‘¥_ _ğ‘–_ _,ğ‘§_ ) _._

_ğ‘–_ âˆˆ[ _ğ‘˜_ ]


Note that the only difference between Ë† _ğ‘_ _ğ‘˜_ _[â˜…]_ [and] _[ ğ‘]_ _ğ‘˜_ _[â˜…]_ [is that] _[ ğ‘§]_ [is not projected in the former. Plugging]
together Lemma 3.20 and Lemma 3.21, we get the following.


Lemma 3.23. _Assuming the Triangle Hypothesis, direct access for_ Ë† _ğ‘_ _[â˜…]_ 2 _[and the variable order]_ _[ ğ‘¥]_ [1] _[ >]_
_ğ‘¥_ 2 _> ğ‘§_ _cannot be done on databases of size ğ‘š_ _with preprocessing time_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) _and access time_ _ğ‘‚_ [Ëœ] (1) _._


Proof. By Lemma 3.20, direct access for Ë† _ğ‘_ _[â˜…]_ 2 [and the order] _[ ğ‘¥]_ [1] _[ >][ ğ‘¥]_ [2] _[ >][ ğ‘§]_ [allows testing for] _[ ğ‘]_ _[â˜…]_ 2
which by Lemma 3.21 requires more than quasi-linear preprocessing. 

Lemma 3.23 motivates the following definition: let _ğ‘_ be a join query and âª¯ an order of its variables.
Three variables _ğ‘¦_ 1 _,ğ‘¦_ 2 _,ğ‘¦_ 3 are called a _disruptive trio_ if _ğ‘¦_ 1 âª¯ _ğ‘¦_ 3, _ğ‘¦_ 2 âª¯ _ğ‘¦_ 3, the pairs _ğ‘¦_ 1 _,ğ‘¦_ 3 and _ğ‘¦_ 2 _,ğ‘¦_ 3
each appear in the scope of a common atom of _ğ‘_ and _ğ‘¦_ 1 _,ğ‘¦_ 2 do not appear in the scope of a common

atom.




Lower Bounds for Conjunctive Query Evaluation 13


It is not hard to see that if a self-join free join query has a disruptive trio with respect to an order
âª¯, then one can embed Ë† _ğ‘_ _[â˜…]_ 2 [into it: define all relations such that all variables not in the disruptive]
trio are fixed to constants, and on the trio simulate the relations _ğ‘…_ 1 and _ğ‘…_ 2 . It can be shown that
such an embedding is actually also possible if the query contains self-joins [ 22 ]. As a consequence,
disruptive trios make direct access hard for join queries. More work is required to show that if
there is no disruptive trio, then the query allows efficient direct access after linear preprocessing,
which is shown in [27]. Together, this gives the following characterization.


Theorem 3.24. _Assume the Triangle Hypothesis and the Hyperclique Hypothesis. Then there is a_
_direct access algorithm for a join query_ _ğ‘_ _for a lexicographic order induced by an order_ âª¯ _on databases_
_of size_ _ğ‘š_ _with preprocessing time_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) _and access time_ _ğ‘‚_ [Ëœ] ( 1 ) _if and only if_ _ğ‘_ _is acyclic and has no_
_disruptive trio with respect to_ âª¯ _._


We remark that [ 27 ] in fact shows a version of Theorem 3.24 that has the Sparse Boolean Matrix
Multiplication Hypothesis as an additional assumption. This is because the authors there use
Theorem 3.16 in the lower bound which makes use of this assumption. By using the more direct
approach of Lemma 3.21, we could avoid introducing it for Theorem 3.24.


_3.4.2_ _Sum Orders._ We will now consider another way of ordering the tuples in a query result, this
time by the _sum order_ which is defined as follows: assign a weight _ğ‘¤_ ( _ğ‘_ ) to every element of the
domain of the database, then the weight _ğ‘¤_ ( _ğ‘_ 1 _, . . .,ğ‘_ _ğ‘Ÿ_ ) of a tuple ( _ğ‘_ 1 _, . . .,ğ‘_ _ğ‘Ÿ_ ) is the sum [ï¿½] _ğ‘–_ âˆˆ[ _ğ‘Ÿ_ ] _[ğ‘¤]_ [(] _[ğ‘]_ _ğ‘–_ [)]
of weights of its entries. The query result is then ordered by the weight defined this way. This
type of orders is more expressive than lexicographic orders and has for example been considered
in [ 7, 36, 73 ]. We will here present work from [ 27 ], however, in contrast to there, to simplify the
presentation, we will only consider join queries, so queries without projections. We will see that
the class of queries that allows linear time preprocessing direct access is extremely restricted in
this setting.
We will use an additional hypothesis. The _3SUM problem_ is, given as input three lists _ğ´_, _ğµ_, _ğ¶_ of
length _ğ‘›_ consisting of integers in {âˆ’ _ğ‘›_ [4] _, . . .,ğ‘›_ [4] }, to decide if there are _ğ‘_ âˆˆ _ğ´_, _ğ‘_ âˆˆ _ğµ_ and _ğ‘_ âˆˆ _ğ¶_ such
that _ğ‘_ + _ğ‘_ = _ğ‘_ . The 3SUM problem has an easy algorithm with complexity _ğ‘‚_ [Ëœ] ( _ğ‘›_ [2] ) : compute the set
_ğ‘†_ : = { _ğ‘_ + _ğ‘_ | _ğ‘_ âˆˆ _ğ´,ğ‘_ âˆˆ _ğµ_ } and sort it. Then going over the _ğ‘†_ and _ğ¶_ in increasing order, check if
there is a common element in both lists. While this runtime can be slightly improved, see e.g. the
discussion in [78], there is no known algorithm with runtime _ğ‘‚_ [Ëœ] ( _ğ‘›_ [2][âˆ’] _[ğœ€]_ ) for any constant _ğœ€_ _>_ 0.


Ëœ Hypothesis 5 ( _3SUM Hypothesis_ ). _There is no algorithm for the 3SUM problem with runtime_
_ğ‘‚_ ( _ğ‘›_ [2][âˆ’] _[ğœ€]_ ) _for any ğœ€_ _>_ 0 _._


The 3SUM Hypothesis was first introduced in [ 43 ] where it was connected to the complexity of
many problems from computational geometry. Since then it has become one of the most used and
important hypotheses in fine-grained complexity, see again [78] for a discussion.
The following connection of 3SUM to direct access is from [ 27 ], in slightly different formulation.


Lemma 3.25. _Assume the 3SUM Hypothesis. Let_ _ğ‘_ _be a self-join free join query such that there are_
_two variables_ _ğ‘¥_ _,_ _ğ‘¦_ _such that no atom of_ _ğ‘_ _contains both_ _ğ‘¥_ _and_ _ğ‘¦_ _. Then there is no_ _ğœ€_ _>_ 0 _such that there_
_is a direct access algorithm for_ _ğ‘_ _on databases of size_ _ğ‘š_ _with sum order, preprocessing time_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ [2][âˆ’] _[ğœ€]_ )
_and access time_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ [1][âˆ’] _[ğœ€]_ ) _._


Proof. We reduce from 3SUM, so let _ğ´_, _ğµ_, _ğ¶_ be the input lists. We construct a database _ğ·_ with
domain _ğ´_ âˆª _ğµ_ âˆª{ 0 } . In all relations, the variables outside of _ğ‘¥_ and _ğ‘¦_ can only take the value 0,
while _ğ‘¥_ can take all values in _ğ´_ and _ğ‘¦_ all values in _ğµ_ . Since _ğ‘¥_ and _ğ‘¦_ do not appear in the scope of a




14 Stefan Mengel


common atom, the resulting database has size _ğ‘‚_ ( _ğ‘›_ ) . As weight function _ğ‘¤_, we simply set _ğ‘¤_ ( _ğ‘‘_ ) = _ğ‘‘_
for all elements in the domain.
By construction, _ğ‘_ ( _ğ·_ ) contains a tuple of weight _ğ‘_ if and only if there are _ğ‘_ âˆˆ _ğµ,ğ‘_ âˆˆ _ğµ_ such
that _ğ‘_ + _ğ‘_ = _ğ‘_ . We solve 3SUM as follows: first, run the preprocessing on _ğ·_, then iterate over all
elements _ğ‘_ âˆˆ _ğ¶_ and check if _ğ‘_ ( _ğ·_ ) contains a tuple of weight _ğ‘_ . To do the latter, use binary search
with the help of Ëœ _ğ‘‚_ (log( _ğ‘›_ )) access queries. Assuming preprocessing time _ğ‘‚_ [Ëœ] ( _ğ‘š_ [2][âˆ’] _[ğœ€]_ ) and access time
_ğ‘‚_ ( _ğ‘š_ [1][âˆ’] _[ğœ€]_ ), the overall runtime is _ğ‘‚_ ( _ğ‘›_ [2][âˆ’] _[ğœ€]_ ) which breaks the 3SUM Hypothesis. 

One can show that the only acyclic queries that are not hard by Lemma 3.25 are those containing
an atom which has all variables in its scope. This is because for acyclic hypergraphs the size of
the smallest edge cover and that of the biggest independent set are equal [ 39, Lemma 19], so if the
variables are not all in the scope of one atom, then the criterion of Lemma 3.25 applies. But for
queries in which all variables are in one atom, we can easily materialize the query result and sort it
in time _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) and thus get efficient direct access. So we get the following characterization.


Theorem 3.26. _Assume the 3SUM Hypothesis. Then there is a direct access algorithm for an acyclic_
_self-join free join query_ _ğ‘_ _for sum order on databases of size_ _ğ‘š_ _with preprocessing time_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) _and_
_delay_ _ğ‘‚_ [Ëœ] (1) _if and only if ğ‘_ _contains an atom which has all variables of ğ‘_ _in its scope._


**4** **BEYOND LINEAR TIME**


In this section, we will discuss to which extent the results seen before can be extended to showing
superlinear lower bounds. Unfortunately, there are so far less powerful techniques for this, in
particular for Boolean queries. There are mainly two problems we would have to overcome to
show lower bounds similar to those of Section 3: first, we would need an analogue of Theorem 3.6
that shows that in â€œhardâ€ instances we can always embed certain restricted and well-behaved
sub-instances. Second, we need plausible hardness assumptions on these sub-instances.
Unfortunately, there seem to be no good answers to either of these problems that are as generally
useful as in the linear time case. That said, there are techniques for both that allow us to still infer
interesting results. We will sketch some of them in the next two sub-sections. After that, we will
quickly mention results for counting and direct access that allow showing good lower bounds with
slightly different techniques.


**4.1** **Clique Variants**

In many settings in complexity theory, the Clique problem has served as a starting point for
hardness, see e.g. [ 56 ] and [ 32, Chapter 13]. Therefore, it is natural to base fine-grained lower
bounds for query answering also on this problem. To this end, it would be convenient to have
a very strong hardness assumption for _ğ‘˜_ -Clique, saying that _ğ‘˜_ -Clique cannot be solved in time
_ğ‘‚_ ( _ğ‘›_ _[ğ‘˜]_ [âˆ’] _[ğœ€]_ ). Unfortunately, it has long been observed that this statement is false.


Theorem 4.1. _[_ _64_ _] For every_ _ğ‘˜_ _, there is an algorithm with runtime_ _ğ‘‚_ [Ëœ] ( _ğ‘›_ _[ğœ”]_ [âŒŠ] _[ğ‘˜]_ 3 [âŒ‹+] _[ğ‘–]_ ) _for_ _ğ‘˜_ _-clique where_ _ğ‘–_

_is the rest of ğ‘˜_ _after division by_ 3 _._



Proof. We will only sketch the idea for _ğ‘–_ = 0. We set _ğ‘Ÿ_ : = _[ğ‘˜]_



Proof. We will only sketch the idea for _ğ‘–_ = 0. We set _ğ‘Ÿ_ : = 3 [. Let] _[ ğº]_ [be an input graph. We]

construct a new graph _ğº_ [â€²] whose vertices are the _ğ‘Ÿ_ -cliques of _ğº_ . Two such cliques _ğ¶_ 1 _,ğ¶_ 2 are
connected by an edge if and only if they are disjoint and form a clique of size 2 _ğ‘Ÿ_ . There are at most
_ğ‘›_ _ğ‘˜_ 2 _ğ‘˜_
ï¿½ _ğ‘Ÿ_ ï¿½ = _ğ‘‚_ ( _ğ‘›_ 3 ) potential vertices for _ğº_ [â€²] to consider and thus _ğ‘‚_ ( _ğ‘›_ 3 ) potential edges in _ğº_ [â€²] . It follows



2 _ğ‘˜_
3 ) potential vertices for _ğº_ [â€²] to consider and thus _ğ‘‚_ ( _ğ‘›_ 3



_ğ‘›_
ï¿½ _ğ‘Ÿ_ ï¿½ = _ğ‘‚_ ( _ğ‘›_ 3 ) potential vertices for _ğº_ [â€²] to consider and thus _ğ‘‚_ ( _ğ‘›_ 3 ) potential edges in _ğº_ [â€²] . It follows

that we can construct _ğº_ [â€²] easily within the allowed time-bound.




Lower Bounds for Conjunctive Query Evaluation 15


Now observe that the triangles in _ğº_ [â€²] are exactly the _ğ‘˜_ -cliques in _ğº_ . So we can use the matrix
multiplication based algorithm for triangles as in the second part of the proof of Theorem 3.2 to
_ğœ”ğ‘˜_
decide in time _ğ‘‚_ [Ëœ] ( _ğ‘›_ _[ğœ”ğ‘Ÿ]_ ) = _ğ‘‚_ [Ëœ] ( _ğ‘›_ 3 ) if _ğº_ contains a _ğ‘˜_ -clique. 

We remark that the exponents for _ğ‘˜_ -clique that we get from Theorem 4.1 by plugging in the best
known bounds for _ğœ”_ can be slightly improved in the cases _ğ‘–_ âˆˆ{2 _,_ 3} [40].
In the light of Theorem 4.1, _ğ‘˜_ -Clique as such does not seem to be a good candidate for tight
lower bound proofs, even though it is still useful in settings that have known matrix multiplication
based algorithms, see e.g. [ 1 ]. There are two main ways of modifying the clique problem to make it
more useful in our setting: either restricting the computational model or using harder variants of
_ğ‘˜_ -Clique. We will quickly discuss both of these approaches in the remainder of this section.


_4.1.1_ _Restricted Computation: Combinatorial Algorithms._ There is a line of work that considers
only restricted, so-called _combinatorial_ algorithms for _ğ‘˜_ -Clique and related problems. This notion
is not formally defined, but mostly motivated by the fact that the only results that beat _ğ‘‚_ [Ëœ] ( _ğ‘›_ _[ğ‘˜]_ ) -time
exhaustive search algorithms for _ğ‘˜_ -Clique by a factor of _ğ‘›_ _[ğœ€]_ for any constant _ğœ€_ _>_ 0 are all based on
efficient matrix multiplication. This state of affairs is often considered as unsatisfying: algorithms
using fast matrix multiplication are in a sense uninterpretable since intermediate values computed
in them have no apparent interpretation in terms of the original problem. Also, these algorithms
often do not generalize to problem variants, see the next section. Finally, it has long been argued
that the asymptotically best known algorithms are impractical due to huge hidden constants, see
e.g. [44], which makes all algorithms relying on them also impractical.
As a consequence of all these issues, many works consider combinatorial algorithms which,
while the concept is not formally defined, are often informally understood to not use any algebraic
cancellations and have reasonable constants, see e.g. [ 3, Section 1.2] for a detailed discussion. A
very popular conjecture for combinatorial algorithms is the following.


Hypothesis 6 ( _Combinatorial_ _ğ‘˜_ _-Clique Hypothesis_ ). _Combinatorial algorithms cannot solve_
_ğ‘˜-Clique in time_ _ğ‘‚_ [Ëœ] ( _ğ‘›_ _[ğ‘˜]_ [âˆ’] _[ğœ€]_ ) _on graphs with ğ‘›_ _vertices for any ğœ€_ _>_ 0 _and ğ‘˜_ â‰¥ 3 _._


There are analogous hypotheses for combinatorial algorithms for other problems such as Boolean
matrix multiplication and triangle finding, see [ 76 ]. Moreover, the best known combinatorial
algorithms are faster than the naive approach and have runtime _ğ‘œ_ ( _ğ‘›_ _[ğ‘˜]_ ) ; the current record is
_ğ‘‚_ ( _ğ‘›_ _[ğ‘˜]_ (log( _ğ‘›_ )) [âˆ’(] _[ğ‘˜]_ [+][1][)] log log( _ğ‘›_ ) _[ğ‘˜]_ [+][3] ) [3].
The Combinatorial _ğ‘˜_ -Clique Hypothesis has been used as a starting point to rule out combinatorial
algorithms, see again [ 3 ] for references. In database theory, it has been used to argue that known
combinatorial algorithms for e.g. cycle joins and Loomis-Whitney joins are optimal [41].
So what should we take away from this line of work? First, lower bounds for combinatorial
algorithms are certainly valuable in the sense that they give us insights on algorithms that one
would actually like to implement in practice. Also, since clique is often a convenient problem to
reduce from, lower bounds for combinatorial algorithms are often easier to get than lower bounds
for general algorithms. That said, since â€œcombinatorial algorithmsâ€ have no formal, generally
agreed upon definition, the reader might feel somewhat uneasy to show these lower bounds.
Mathematically speaking, what is it that is even shown? Also, there are situations in which there are
(non-combinatorial) algorithms that are better than the lower bounds for combinatorial algorithms.
We have seen this for _ğ‘˜_ -clique, but the same is true for other problems, e.g. parsing context
free languages [ 74 ]. Similarly, there are matrix multiplication based algorithms for directed cycle
detection that are better than any combinatorial algorithm [ 34, 80 ]. So in conclusion, while lower
bounds based on the Combinatorial _ğ‘˜_ -Clique Hypothesis are useful, if possible one should at least




16 Stefan Mengel


complement them with lower bounds for general algorithms based on other credible assumptions.
For example, we have seen this for Loomis-Whitney joins in Section 3.1.1.


_4.1.2_ _Harder Variants of_ _ğ‘˜_ _-Clique._ Since, as we have seen, _ğ‘˜_ -Clique is in a sense â€œnot hard enoughâ€,
several variants of _ğ‘˜_ -Clique have been introduced that are presumably harder. We will sketch some
here.

One variant of _ğ‘˜_ -Clique that we have already seen in Section 3.1.1 is the Hyperclique problem
and the corresponding Hyperclique Hypothesis. We have see there that this conjecture was useful
for Loomis-Whitney joins and thus all cyclic queries. Unfortunately, hypergraphs are often harder
to embed into other problems, so weighted variants of _ğ‘˜_ -Clique on graphs have been studied.
To this end, we consider graphs _ğº_ = ( _ğ‘‰, ğ¸_ ) that have an additional edge weight function
_ğ‘¤_ : _ğ¸_ â†’ Z . We consider two problems on such weighted graphs: Min-Weight- _ğ‘˜_ -Clique is the
problem, given an edge weighted graph _ğº_, to compute a _ğ‘˜_ -clique _ğ¶_ such that the sum of the edge
weights of _ğ¶_ is minimal. The Zero- _ğ‘˜_ -Clique problem is, given an edge weighted graph _ğº_, to decide
if _ğº_ contains a _ğ‘˜_ -clique _ğ¶_ such that the sum of the edges weights in _ğ¶_ is 0. It is widely conjectured
that the addition of edge weights makes _ğ‘˜_ -Clique harder and that both problems do not have
algorithms that are much better than _ğ‘‚_ [Ëœ] ( _ğ‘›_ _[ğ‘˜]_ ).


Hypothesis 7 ( _Min-Weight-_ _ğ‘˜_ _-Clique Hypothesis_ ). _There is no algorithm that solves Min-Weight-_
_ğ‘˜-Clique in time_ _ğ‘‚_ [Ëœ] ( _ğ‘›_ _[ğ‘˜]_ [âˆ’] _[ğœ€]_ ) _on graphs with ğ‘›_ _vertices for any ğœ€_ _>_ 0 _and ğ‘˜_ â‰¥ 3 _._


Hypothesis 8 ( _Zero-_ _ğ‘˜_ _-Clique Hypothesis_ ). _There is no algorithm that solves Zero-_ _ğ‘˜_ _-Clique in_
_time_ _ğ‘‚_ [Ëœ] ( _ğ‘›_ _[ğ‘˜]_ [âˆ’] _[ğœ€]_ ) _on graphs with ğ‘›_ _vertices for any ğœ€_ _>_ 0 _and ğ‘˜_ â‰¥ 3 _._


Observe that there are also node-weighted _ğ‘˜_ -clique variants defined analogously to the problems
above. However, for those problem there are matrix multiplication based algorithms that are faster
than _ğ‘‚_ [Ëœ] ( _ğ‘›_ _[ğ‘˜]_ ) [33, 77].
The Zero- _ğ‘˜_ -Clique Hypothesis sometimes also goes under the name _Exact-Weight-_ _ğ‘˜_ _-Clique_
_Hypothesis_ . Both of the above conjectures have been used extensively in fine-grained complexity, for
some recent pointers into the literature see e.g. [ 23 ]. We will restrict ourselves here to applications
in database theory.
The Min-Weight- _ğ‘˜_ -Clique Hypothesis is useful in the setting of aggregate queries over semirings [ 59 ]. To simplify the setting, let us only consider queries over the tropical (min _,_ +) -semiring, a
setting which we quickly sketch here: consider a join query _ğ‘_ ( _ğ‘‹_ ) :âˆ’ _ğ‘…_ 1 ( _ğ‘‹_ 1 ) _, . . ., ğ‘…_ _â„“_ ( _ğ‘‹_ _â„“_ ) . Let _ğ·_ be a
weighted database, i.e. a database in which all tuples _ğ‘¡_ are assigned weights _ğ‘¤_ ( _ğ‘¡_ ) from R âˆª{âˆ} .
We then extend this weight to query answers in _ğ‘_ ( _ğ·_ ) by making for _ğ‘_ âˆˆ _ğ‘_ ( _ğ·_ ) the definition
_ğ‘¤_ ( _ğ‘_ ) : = _ğ‘¤_ ( _ğœ‹_ _ğ‘‹_ 1 ( _ğ‘_ )) + _. . ._ + _ğ‘¤_ ( _ğœ‹_ _ğ‘‹_ _â„“_ ( _ğ‘_ )) where _ğœ‹_ _ğ‘‹_ _ğ‘–_ denotes projection onto the set _ğ‘‹_ _ğ‘–_ . The answer to
the aggregate query is then defined as min _ğ‘_ âˆˆ _ğ‘_ ( _ğ·_ ) ( _ğ‘¤_ ( _ğ‘_ )).
If we consider the join query _ğ‘_ _ğ‘˜_ ( _ğ‘¥_ 1 _, . . .,ğ‘¥_ _ğ‘˜_ ) :âˆ’ [ï¿½] _ğ‘–,ğ‘—_ âˆˆ[ _ğ‘˜_ ] _,ğ‘–_ â‰  _ğ‘—_ _[ğ¸]_ [(] _[ğ‘¥]_ _ğ‘–_ _[,ğ‘¥]_ _ğ‘—_ [)] [, we get a reformulation of]
the Min-Weight- _ğ‘˜_ -Clique problem, so hardness follows directly from the Min-Weight- _ğ‘˜_ -Clique
Hypothesis. More interestingly, this can be combined with the so-called clique embeddings which
we will discuss in Section 4.2.

For applications of the Zero- _ğ‘˜_ -Clique Hypothesis, see Section 4.3


**4.2** **Clique Embeddings**


Having seen several hardness assumptions for the clique problem, we will in this section sketch on
an example how _clique embeddings_ for queries are defined and can be used to apply the hardness




Lower Bounds for Conjunctive Query Evaluation 17

![](images/2506.17702v1.pdf-16-0.png)


Fig. 1. Visualization of the embedding in Example 4.2. In each node of the cycle, we first give the name of the
node and then, separated by a colon, the list of vertices of the 5-clique that are mapped to it.


assumptions to more general queries. The techniques sketched here are essentially taken from [ 41 ]
and build on ideas from [62].
The idea is that we will let the variables of a query _ğ‘_ choose vertices in a graph that potentially
might belong to a clique and then construct a database to use the query to check if all necessary
edges between vertices are present in the input graph. To do so, we have to decide which variable
in the query is responsible for choosing which vertex. To this end, we choose an assignment _ğœ“_
of the vertices of a clique _ğ¾_ _â„“_ to vertices in the hypergraph _ğ»_ = ( _ğ‘‰, ğ¸_ ) of the query _ğ‘_ we want to
analyze. This assignment _ğœ“_ has the following properties:


(1) every vertex _ğ‘¥_ _ğ‘–_ of _ğ¾_ _â„“_ can be mapped to several vertices of _ğ»_, so _ğœ“_ maps to the subsets of _ğ‘‰_ .
To make sure that the choice of nodes in the variables is consistent, we require that _ğœ“_ ( _ğ‘¥_ _ğ‘–_ ) is
connected in _ğ»_ for every vertex of _ğ‘¥_ _ğ‘–_ of _ğ¾_ _â„“_ .
(2) for every pair _ğ‘¥_ _ğ‘–_ _,ğ‘¥_ _ğ‘—_ of _ğ¾_ _â„“_, we have that _ğœ“_ ( _ğ‘¥_ _ğ‘–_ ) âˆ© _ğœ“_ ( _ğ‘¥_ _ğ‘—_ ) â‰  âˆ… or there exists some _ğ‘’_ âˆˆ _ğ¸_ such
that _ğœ“_ ( _ğ‘¥_ _ğ‘–_ ) âˆ© _ğ‘’_ â‰  âˆ… and _ğœ“_ ( _ğ‘¥_ _ğ‘–_ ) âˆ© _ğ‘’_ â‰  âˆ….


_Example 4.2._ Consider the 5-cycle query


_ğ‘_ 5 [â—¦] [:][âˆ’] _[ğ‘…]_ [1] [(] _[ğ‘£]_ [1] _[, ğ‘£]_ [2] [)] _[, . . ., ğ‘…]_ [4] [(] _[ğ‘£]_ [4] _[, ğ‘£]_ [5] [)] _[, ğ‘…]_ [5] [(] _[ğ‘£]_ [5] _[, ğ‘£]_ [1] [)] _[.]_


We embed a 5-clique on vertices _ğ‘¥_ 1 _, . . .,ğ‘¥_ 5 by setting


_ğœ“_ ( _ğ‘¥_ 1 ) := { _ğ‘£_ 1 _, ğ‘£_ 2 _, ğ‘£_ 3 } _,_


_ğœ“_ ( _ğ‘¥_ 2 ) := { _ğ‘£_ 2 _, ğ‘£_ 3 _, ğ‘£_ 4 } _,_


_ğœ“_ ( _ğ‘¥_ 3 ) := { _ğ‘£_ 3 _, ğ‘£_ 4 _, ğ‘£_ 5 } _,_


_ğœ“_ ( _ğ‘¥_ 4 ) := { _ğ‘£_ 4 _, ğ‘£_ 5 _, ğ‘£_ 1 } _,_


_ğœ“_ ( _ğ‘¥_ 5 ) := { _ğ‘£_ 5 _, ğ‘£_ 1 _, ğ‘£_ 2 }


This mapping is visualized in Figure 1 and has the properties we described above.


Having fixed _ğœ“_, we now show how to use _ğ‘_ to solve clique problems: given an input graph
_ğº_ = ( _ğ‘‰_ _ğº_ _, ğ¸_ _ğº_ ), we construct a database _ğ·_ . The domain of a variable _ğ‘£_ of _ğ‘_ is _ğ‘‰_ _ğº_ _[ğœ“]_ [âˆ’][1] [(] _[ğ‘£]_ [)], so intuitively, _ğ‘£_
choses a vertex of _ğº_ for every node _ğ‘¥_ _ğ‘–_ in the clique _ğ¾_ _â„“_ with _ğ‘£_ âˆˆ _ğœ“_ ( _ğ‘¥_ _ğ‘–_ ) . The relations of _ğ·_ are
constructed to satisfy two criteria: first, for every atom, if _ğ‘£,ğ‘¢_ âˆˆ _ğœ“_ ( _ğ‘¥_ _ğ‘–_ ) for some _ğ‘¥_ _ğ‘–_ and _ğ‘£,ğ‘¢_ are
variables of the atom, then _ğ‘£_ and _ğ‘¢_ must choose the same value for _ğ‘¥_ _ğ‘–_ . Because of property (1) of _ğœ“_,
it follows that all variables of _ğ‘_ make a consistent choice for all vertices _ğ‘¥_ _ğ‘–_ of _ğ¾_ _â„“_ . Second, whenever
_ğ‘¥_ _ğ‘–_ _,ğ‘¥_ _ğ‘—_ are mapped to variables _ğ‘£,ğ‘¢_ âˆˆ _ğ‘’_ where _ğ‘’_ is an edge of _ğº_ (here the case _ğ‘£_ = _ğ‘¢_ is possible), we
make sure that the choice of vertices from _ğ‘‰_ _ğº_ is such that they are connected by an edge. Because




18 Stefan Mengel


of property (2) of _ğœ“_, we get that the choices for all _ğ‘¥_ _ğ‘–_ of _ğ¾_ _â„“_ are such that every two chosen vertices
must be connected by an edge.
Defining the database like this, the answers to _ğ‘_ are essentially the _â„“_ -cliques in _ğº_ . So the idea is
that, if we are trying to solve a problem that is hard for cliques, we can get a lower bound for the
same problem on _ğ‘_ . The exact lower bound depends on three quantities:


  - the hypothesis on the hardness of the problem on cliques that we make (see the previous
section),

  - the number of vertices from _ğ¾_ _â„“_ that are mapped into the same edge of _ğ»_, since this determines the size of the corresponding relation, and

   - the size _â„“_ of the clique that _ğœ“_ embeds.


_Example 4.3._ Consider again the embedding from Example 4.2. Let | _ğ‘‰_ _ğº_ | = _ğ‘›_ _ğº_ . First, note that
exactly 4 variables are mapped to every edge, so the database has size _ğ‘‚_ ( _ğ‘›_ _ğº_ [4] [)] [. We have] _[ â„“]_ [=] [ 5. Let us]
assume that we want to solve the min-weight _â„“_ -clique problem which, assuming the Min-Weight_ğ‘˜_ -Clique Hypothesis takes time _ğ‘›_ _ğº_ [5] [. Now assume that we can solve the aggregation problem for]
5
_ğ‘_ 5 [â—¦] [over the tropical semi-ring (see Section 4.1.2)in time] [ Ëœ] _[ğ‘‚]_ [(] _[ğ‘š]_ 4 [âˆ’] _[ğœ€]_ ) . Then, by the encoding, we can
solve it in 5-cliques in time _ğ‘‚_ [Ëœ] ( _ğ‘š_ 54 ) = _ğ‘‚_ [Ëœ] ( _ğ‘›_ [4][Â·] [5] 4 [âˆ’] _[ğœ€]_ ) = _ğ‘‚_ [Ëœ] ( _ğ‘›_ [5][âˆ’] _[ğœ€]_ ), which contradicts our assumption.

5
So aggregation on the 5-cycle query cannot be done in time _ğ‘‚_ [Ëœ] ( _ğ‘š_ 4 [âˆ’] _[ğœ€]_ ) and we have reduced our
hardness hypothesis for cliques to the 5-cycle with the help of the embedding.


The techniques that we have only sketched here can be developed into a measure for queries
called _clique embedding power_ which allows showing lower bounds similar to that in Example 4.3
systematically, see [ 41 ] for details. For example, this approach allows showing lower bounds for
aggregation over the tropical semiring for all cycle queries and Loomis-Whitney joins. Moreover,
it can also be used to show lower bounds for the _submodular width_ of queries, an important
hypergraph width measure that is known to yield algorithms that are optimal in parameterized
complexity [60, 62].


**4.3** **Direct Access**

The query answering task that is best understood out of those that we discuss in this paper,
is certainly direct access with lexicographic orders. As we have seen in Section 3.4, the linear
preprocessing case was solved in [ 27 ]. In [ 22 ] this was generalized by introducing a parameter
called _incompatibility number_ that is then shown to be the exact exponent of an optimal direct
access algorithm. For details, we refer the reader to [22].
Conceptually, the proof in [ 22 ] consists of two steps: in one step, one has to show tight lower
bounds for one specific class of queries; in a second step, one has to show how to embed these
queries. Concretely, the following generalization of Lemma 3.21 is shown for the queries Ë† _ğ‘_ _ğ‘˜_ _[â˜…]_ [.]


Lemma 4.4. _Assuming the Zero-_ _ğ‘˜_ _-Clique Hypothesis, there is no testing algorithm for_ Ë† _ğ‘_ _ğ‘˜_ _[â˜…]_ _[with]_
_preprocessing time_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ _[ğ‘˜]_ [âˆ’] _[ğœ€]_ ) _and testing time_ _ğ‘‚_ [Ëœ] (1) _on databases of size ğ‘š_ _for any ğ‘˜_ â‰¥ 2 _, ğœ€_ _>_ 0 _._


Unfortunately, the proof of Lemma 4.4 is far more involved than that of Lemma 3.21 and is
thus beyond the scope of this paper. Very similar techniques are used in [ 22 ] to show a variant of
Theorem 3.14 that does not depend on the Triangle and Hyperclique Hypotheses.


Theorem 4.5. _Assume the Zero-_ _ğ‘˜_ _-Clique Hypothesis. Then there is an enumeration algorithm for a_
_self-join free join query_ _ğ‘_ _with preprocessing time_ _ğ‘‚_ [Ëœ] ( _ğ‘š_ ) _and constant delay on instances of size_ _ğ‘š_ _if_
_and only if ğ‘_ _is acyclic._


This gives even more confidence that the characterization of Theorem 3.14 is likely correct.




Lower Bounds for Conjunctive Query Evaluation 19


**4.4** **Counting for Acyclic Queries**


For counting for acyclic conjunctive queries, one can get a better understanding of the superlinear
time cases. The idea is that one can can define a measure called _quantified star size_ that generalizes
the property of being free-connex. This notion was first introduced in [ 39 ] for acyclic queries
and then developed further in [ 30, 37, 38 ]. We will not give the slightly involved definition here;
intuitively, it measures the size of the biggest query _ğ‘_ _ğ‘˜_ _[â˜…]_ [from Section 3.2 that can be embedded into]
a query. Using Lemma 3.9, we then get a lower bound.


Theorem 4.6. _Let_ _ğ‘_ _be a self-join free conjunctive query of quantified star size_ _ğ‘˜_ _. Then, assuming_
_that SAT has no algorithm with runtime_ 2 _[ğ‘›]_ [(][1][âˆ’] _[ğ›¿]_ [)] _for any_ _ğ›¿_ _>_ 0 _, there is no algorithm that counts the_
_solutions of ğ‘_ _on a database with ğ‘š_ _tuples in time ğ‘š_ _[ğ‘˜]_ [âˆ’] _[ğœ€]_ [â€²] _for any ğœ€_ [â€²] _>_ 0 _._


See [63] for more details.
For the non-acyclic case, tight lower bounds are mostly not known for the same reasons as for
Boolean queries answering. However, the situation is even worse for counting than for decision
since there is no apparent way for how to adapt the best known decision algorithms [ 60, 62 ] to
counting, see [57].


**5** **CONCLUSION**


Let us conclude our short tour of recent lower bound techniques for conjunctive query answering.
The aim was to convince the reader that fine-grained methods and hypotheses are a valuable new
tool for database theorists. Let us stress that, while many of the reductions we presented here are
relatively short and easy, this is certainly not the case for most results in fine-grained complexity
in general. Quite to the contrary, many papers in the area are long and technical; the presentation
here was merely restricted to rather simple techniques and ideas to showcase the area. However,
the complicatedness of fine-grained complexity should not discourage us from approaching and
integrating this area into our work: on the one hand, we have seen that relatively simple techniques
can already lead to interesting results, so we should push them as far as we can. On the other hand,
fine-grained complexity provides an exciting opportunity to learn interesting new techniques,
adapt them and add them to our toolkit.
To keep this paper reasonably short, we have only focused conjunctive query answering in this
survey and not mentioned other applications of fine-grained complexity in database theory. One
important area that we neglected is query answering under updates for which many tight bounds
are known, see e.g. [ 15, 16, 53 â€“ 55 ]. There is also recent work that instead of only time studies also
space bounds [ 81 ]. Beyond this, queries with negation have been studied in [ 18, 19, 24, 82 ]. There
are also highly nontrivial results on answering UCQs[ 21, 25 ]. Finally, lower bounds for regular
path queries have been studied in [28].


**REFERENCES**


[1] Amir Abboud, Arturs Backurs, and Virginia Vassilevska Williams. If the Current Clique Algorithms Are Optimal, so Is
Valiantâ€™s Parser. _SIAM J. Comput._ [, 47(6):2527â€“2555, 2018. doi:10.1137/16M1061771.](https://doi.org/10.1137/16M1061771)

[2] Amir Abboud, Karl Bringmann, Nick Fischer, and Marvin KÃ¼nnemann. The time complexity of fully sparse matrix
multiplication. In David P. Woodruff, editor, _Proceedings of the 2024 ACM-SIAM Symposium on Discrete Algorithms, SODA_
_2024, Alexandria, VA, USA, January 7-10, 2024_ [, pages 4670â€“4703. SIAM, 2024. doi:10.1137/1.9781611977912.167.](https://doi.org/10.1137/1.9781611977912.167)

[3] Amir Abboud, Nick Fischer, and Yarin Shechter. Faster combinatorial k-clique algorithms. In JosÃ© A. Soto and Andreas
Wiese, editors, _LATIN 2024: Theoretical Informatics - 16th Latin American Symposium, Puerto Varas, Chile, March_
_18-22, 2024, Proceedings, Part I_, volume 14578 of _Lecture Notes in Computer Science_, pages 193â€“206. Springer, 2024.
[doi:10.1007/978-3-031-55598-5\_13.](https://doi.org/10.1007/978-3-031-55598-5_13)

[4] Amir Abboud and Virginia Vassilevska Williams. Popular conjectures imply strong lower bounds for dynamic problems.
In _55th IEEE Annual Symposium on Foundations of Computer Science, FOCS 2014, Philadelphia, PA, USA, October 18-21,_
_2014_ [, pages 434â€“443. IEEE Computer Society, 2014. doi:10.1109/FOCS.2014.53.](https://doi.org/10.1109/FOCS.2014.53)




20 Stefan Mengel


[5] Josh Alman, Ran Duan, Virginia Vassilevska Williams, Yinzhan Xu, Zixuan Xu, and Renfei Zhou. More asymmetry
yields faster matrix multiplication. In Yossi Azar and Debmalya Panigrahi, editors, _Proceedings of the 2025 Annual_
_ACM-SIAM Symposium on Discrete Algorithms, SODA 2025, New Orleans, LA, USA, January 12-15, 2025_, pages 2005â€“2039.
[SIAM, 2025. doi:10.1137/1.9781611978322.63.](https://doi.org/10.1137/1.9781611978322.63)

[6] Noga Alon, Raphael Yuster, and Uri Zwick. Finding and counting given length cycles. _Algorithmica_, 17(3):209â€“223,
[1997. doi:10.1007/BF02523189.](https://doi.org/10.1007/BF02523189)

[7] Antoine Amarilli, Pierre Bourhis, Florent Capelli, and MikaÃ«l Monet. Ranked enumeration for MSO on trees via
knowledge compilation. In Graham Cormode and Michael Shekelyan, editors, _27th International Conference on_
_Database Theory, ICDT 2024, March 25-28, 2024, Paestum, Italy_, volume 290 of _LIPIcs_, pages 25:1â€“25:18. Schloss Dagstuhl

[- Leibniz-Zentrum fÃ¼r Informatik, 2024. URL: https://doi.org/10.4230/LIPIcs.ICDT.2024.25,](https://doi.org/10.4230/LIPIcs.ICDT.2024.25) [doi:10.4230/LIPICS.](https://doi.org/10.4230/LIPICS.ICDT.2024.25)

[ICDT.2024.25.](https://doi.org/10.4230/LIPICS.ICDT.2024.25)

[8] Rasmus Resen Amossen and Rasmus Pagh. Faster join-projects and sparse matrix multiplications. In Ronald Fagin,
editor, _Database Theory - ICDT 2009, 12th International Conference, St. Petersburg, Russia, March 23-25, 2009, Proceedings_,
volume 361 of _ACM International Conference Proceeding Series_, pages 121â€“126. ACM, 2009. [doi:10.1145/1514894.](https://doi.org/10.1145/1514894.1514909)

[1514909.](https://doi.org/10.1145/1514894.1514909)

[9] Marcelo Arenas, Pablo BarcelÃ³, Leonid Libkin, Wim Martens, and Andreas Pieris. _Database Theory_ [. Open access at https:](https://github.com/pdm-book/community)
[//github.com/pdm-book/community, 2022. accessed March 2025, commit 9f403e4f8bb14eccca301eda2feafe90179b98df.](https://github.com/pdm-book/community)

[10] Albert Atserias, Martin Grohe, and DÃ¡niel Marx. Size bounds and query plans for relational joins. _SIAM J. Comput._,
[42(4):1737â€“1767, 2013. doi:10.1137/110859440.](https://doi.org/10.1137/110859440)

[11] Guillaume Bagan. _Algorithmes et complexitÃ© des problÃ¨mes dâ€™Ã©numÃ©ration pour lâ€™Ã©valuation de requÃªtes logiques._
_(Algorithms and complexity of enumeration problems for the evaluation of logical queries)_ . PhD thesis, University of
[Caen Normandy, France, 2009. URL: https://tel.archives-ouvertes.fr/tel-00424232.](https://tel.archives-ouvertes.fr/tel-00424232)

[12] Guillaume Bagan, Arnaud Durand, and Etienne Grandjean. On acyclic conjunctive queries and constant delay
enumeration. In Jacques Duparc and Thomas A. Henzinger, editors, _Computer Science Logic, 21st International Workshop,_
_CSL 2007, 16th Annual Conference of the EACSL, Lausanne, Switzerland, September 11-15, 2007, Proceedings_, volume
4646 of _Lecture Notes in Computer Science_ [, pages 208â€“222. Springer, 2007. doi:10.1007/978-3-540-74915-8\_18.](https://doi.org/10.1007/978-3-540-74915-8_18)

[13] Catriel Beeri, Ronald Fagin, David Maier, and Mihalis Yannakakis. On the desirability of acyclic database schemes. _J._
_ACM_ [, 30(3):479â€“513, 1983. doi:10.1145/2402.322389.](https://doi.org/10.1145/2402.322389)

[14] Christoph Berkholz, Fabian Gerhardt, and Nicole Schweikardt. Constant delay enumeration for conjunctive queries: a
tutorial. _ACM SIGLOG News_ [, 7(1):4â€“33, 2020. doi:10.1145/3385634.3385636.](https://doi.org/10.1145/3385634.3385636)

[15] Christoph Berkholz, Jens Keppeler, and Nicole Schweikardt. Answering conjunctive queries under updates. In
Emanuel Sallinger, Jan Van den Bussche, and Floris Geerts, editors, _Proceedings of the 36th ACM SIGMOD-SIGACT-_
_SIGAI Symposium on Principles of Database Systems, PODS 2017, Chicago, IL, USA, May 14-19, 2017_, pages 303â€“318.
[ACM, 2017. doi:10.1145/3034786.3034789.](https://doi.org/10.1145/3034786.3034789)

[16] Christoph Berkholz, Jens Keppeler, and Nicole Schweikardt. Answering ucqs under updates and in the presence of
integrity constraints. In Benny Kimelfeld and Yael Amsterdamer, editors, _21st International Conference on Database_
_Theory, ICDT 2018, March 26-29, 2018, Vienna, Austria_, volume 98 of _LIPIcs_, pages 8:1â€“8:19. Schloss Dagstuhl - Leibniz[Zentrum fÃ¼r Informatik, 2018. URL: https://doi.org/10.4230/LIPIcs.ICDT.2018.8,](https://doi.org/10.4230/LIPIcs.ICDT.2018.8) [doi:10.4230/LIPICS.ICDT.2018.8](https://doi.org/10.4230/LIPICS.ICDT.2018.8) .

[17] Markus BlÃ¤ser. On the complexity of the multiplication of matrices of small formats. _J. Complex._, 19(1):43â€“60, 2003.
[doi:10.1016/S0885-064X(02)00007-9.](https://doi.org/10.1016/S0885-064X(02)00007-9)

[18] Johann Brault-Baron. A negative conjunctive query is easy if and only if it is beta-acyclic. In Patrick CÃ©gielski and
Arnaud Durand, editors, _Computer Science Logic (CSLâ€™12) - 26th International Workshop/21st Annual Conference of the_
_EACSL, CSL 2012, September 3-6, 2012, Fontainebleau, France_, volume 16 of _LIPIcs_, pages 137â€“151. Schloss Dagstuhl [Leibniz-Zentrum fÃ¼r Informatik, 2012. URL: https://doi.org/10.4230/LIPIcs.CSL.2012.137,](https://doi.org/10.4230/LIPIcs.CSL.2012.137) [doi:10.4230/LIPICS.CSL.](https://doi.org/10.4230/LIPICS.CSL.2012.137)

[2012.137.](https://doi.org/10.4230/LIPICS.CSL.2012.137)

[19] Johann Brault-Baron. _De la pertinence de lâ€™Ã©numÃ©ration : complexitÃ© en logiques propositionnelle et du premier ordre._
_(The relevance of the list: propositional logic and complexity of the first order)_ . PhD thesis, University of Caen Normandy,
[France, 2013. URL: https://tel.archives-ouvertes.fr/tel-01081392.](https://tel.archives-ouvertes.fr/tel-01081392)

[20] Johann Brault-Baron. Hypergraph acyclicity revisited. _ACM Comput. Surv._, 49(3):54:1â€“54:26, 2016. [doi:10.1145/](https://doi.org/10.1145/2983573)

[2983573.](https://doi.org/10.1145/2983573)

[21] Karl Bringmann and Nofar Carmeli. Unbalanced triangle detection and enumeration hardness for unions of conjunctive
queries. _Log. Methods Comput. Sci._ [, 21(1), 2025. URL: https://doi.org/10.46298/lmcs-21(1:29)2025,](https://doi.org/10.46298/lmcs-21(1:29)2025) [doi:10.46298/LMCS-](https://doi.org/10.46298/LMCS-21(1:29)2025)
[21(1:29)2025.](https://doi.org/10.46298/LMCS-21(1:29)2025)

[22] Karl Bringmann, Nofar Carmeli, and Stefan Mengel. Tight fine-grained bounds for direct access on join queries. In
Leonid Libkin and Pablo BarcelÃ³, editors, _PODS â€™22: International Conference on Management of Data, Philadelphia, PA,_
_USA, June 12 - 17, 2022_ [, pages 427â€“436. ACM, 2022. doi:10.1145/3517804.3526234.](https://doi.org/10.1145/3517804.3526234)




Lower Bounds for Conjunctive Query Evaluation 21


[23] Karl Bringmann, Nick Fischer, Ivor van der Hoog, Evangelos Kipouridis, Tomasz Kociumaka, and Eva Rotenberg.
Dynamic dynamic time warping. In David P. Woodruff, editor, _Proceedings of the 2024 ACM-SIAM Symposium_
_on Discrete Algorithms, SODA 2024, Alexandria, VA, USA, January 7-10, 2024_, pages 208â€“242. SIAM, 2024. [doi:](https://doi.org/10.1137/1.9781611977912.10)
[10.1137/1.9781611977912.10.](https://doi.org/10.1137/1.9781611977912.10)

[24] Florent Capelli, Nofar Carmeli, Oliver Irwin, and Sylvain Salvati. Direct access for conjunctive queries with negation.
_CoRR_ [, abs/2310.15800, 2023. URL: https://doi.org/10.48550/arXiv.2310.15800,](https://doi.org/10.48550/arXiv.2310.15800) [arXiv:2310.15800](https://arxiv.org/abs/2310.15800), [doi:10.48550/](https://doi.org/10.48550/ARXIV.2310.15800)

[ARXIV.2310.15800.](https://doi.org/10.48550/ARXIV.2310.15800)

[25] Nofar Carmeli and Markus KrÃ¶ll. On the enumeration complexity of unions of conjunctive queries. _ACM Trans._
_Database Syst._ [, 46(2):5:1â€“5:41, 2021. doi:10.1145/3450263.](https://doi.org/10.1145/3450263)

[26] Nofar Carmeli and Luc Segoufin. Conjunctive queries with self-joins, towards a fine-grained enumeration complexity
analysis. In Floris Geerts, Hung Q. Ngo, and Stavros Sintos, editors, _Proceedings of the 42nd ACM SIGMOD-SIGACT-_
_SIGAI Symposium on Principles of Database Systems, PODS 2023, Seattle, WA, USA, June 18-23, 2023_, pages 277â€“289.
[ACM, 2023. doi:10.1145/3584372.3588667.](https://doi.org/10.1145/3584372.3588667)

[27] Nofar Carmeli, Nikolaos Tziavelis, Wolfgang Gatterbauer, Benny Kimelfeld, and Mirek Riedewald. Tractable orders
for direct access to ranked answers of conjunctive queries. _ACM Trans. Database Syst._, 48(1):1:1â€“1:45, 2023. [doi:](https://doi.org/10.1145/3578517)
[10.1145/3578517.](https://doi.org/10.1145/3578517)

[28] Katrin Casel and Markus L. Schmid. Fine-grained complexity of regular path queries. _Log. Methods Comput. Sci._, 19(4),
[2023. URL: https://doi.org/10.46298/lmcs-19(4:15)2023, doi:10.46298/LMCS-19(4:15)2023.](https://doi.org/10.46298/lmcs-19(4:15)2023)

[29] Ashok K. Chandra and Philip M. Merlin. Optimal implementation of conjunctive queries in relational data bases. In
John E. Hopcroft, Emily P. Friedman, and Michael A. Harrison, editors, _Proceedings of the 9th Annual ACM Symposium on_
_Theory of Computing, May 4-6, 1977, Boulder, Colorado, USA_, pages 77â€“90. ACM, 1977. [doi:10.1145/800105.803397](https://doi.org/10.1145/800105.803397) .

[30] Hubie Chen and Stefan Mengel. A trichotomy in the complexity of counting answers to conjunctive queries. In
Marcelo Arenas and MartÃ­n Ugarte, editors, _18th International Conference on Database Theory, ICDT 2015, March 23-27,_
_2015, Brussels, Belgium_, volume 31 of _LIPIcs_, pages 110â€“126. Schloss Dagstuhl - Leibniz-Zentrum fÃ¼r Informatik, 2015.
[URL: https://doi.org/10.4230/LIPIcs.ICDT.2015.110, doi:10.4230/LIPICS.ICDT.2015.110.](https://doi.org/10.4230/LIPIcs.ICDT.2015.110)

[31] Don Coppersmith and Shmuel Winograd. On the asymptotic complexity of matrix multiplication. _SIAM J. Comput._,
[11(3):472â€“492, 1982. doi:10.1137/0211038.](https://doi.org/10.1137/0211038)

[32] Marek Cygan, Fedor V. Fomin, Lukasz Kowalik, Daniel Lokshtanov, DÃ¡niel Marx, Marcin Pilipczuk, Michal Pilipczuk,
and Saket Saurabh. _Parameterized Algorithms_ [. Springer, 2015. doi:10.1007/978-3-319-21275-3.](https://doi.org/10.1007/978-3-319-21275-3)

[33] Artur Czumaj and Andrzej Lingas. Finding a heaviest vertex-weighted triangle is not harder than matrix multiplication.
_SIAM J. Comput._ [, 39(2):431â€“444, 2009. doi:10.1137/070695149.](https://doi.org/10.1137/070695149)

[34] Mina Dalirrooyfard, Thuy-Duong Vuong, and Virginia Vassilevska Williams. Graph pattern detection: Hardness for all
induced patterns and faster noninduced cycles. _SIAM J. Comput._ [, 50(5):1627â€“1662, 2021. doi:10.1137/20M1335054.](https://doi.org/10.1137/20M1335054)

[35] VÃ­ctor Dalmau and Peter Jonsson. The complexity of counting homomorphisms seen from the other side. _Theor. Comput._
_Sci._ [, 329(1-3):315â€“323, 2004. URL: https://doi.org/10.1016/j.tcs.2004.08.008, doi:10.1016/J.TCS.2004.08.008.](https://doi.org/10.1016/j.tcs.2004.08.008)

[36] Shaleen Deep, Xiao Hu, and Paraschos Koutris. Ranked enumeration of join queries with projections. _Proc. VLDB Endow._,
[15(5):1024â€“1037, 2022. URL: https://www.vldb.org/pvldb/vol15/p1024-deep.pdf, doi:10.14778/3510397.3510401.](https://www.vldb.org/pvldb/vol15/p1024-deep.pdf)

[37] Holger Dell, Marc Roth, and Philip Wellnitz. Counting answers to existential questions. In Christel Baier, Ioannis
Chatzigiannakis, Paola Flocchini, and Stefano Leonardi, editors, _46th International Colloquium on Automata, Languages,_
_and Programming, ICALP 2019, July 9-12, 2019, Patras, Greece_, volume 132 of _LIPIcs_, pages 113:1â€“113:15. Schloss
[Dagstuhl - Leibniz-Zentrum fÃ¼r Informatik, 2019. URL: https://doi.org/10.4230/LIPIcs.ICALP.2019.113,](https://doi.org/10.4230/LIPIcs.ICALP.2019.113) [doi:10.4230/](https://doi.org/10.4230/LIPICS.ICALP.2019.113)

[LIPICS.ICALP.2019.113.](https://doi.org/10.4230/LIPICS.ICALP.2019.113)

[38] Arnaud Durand and Stefan Mengel. Structural tractability of counting of solutions to conjunctive queries. In WangChiew Tan, Giovanna Guerrini, Barbara Catania, and Anastasios Gounaris, editors, _Joint 2013 EDBT/ICDT Conferences,_
_ICDT â€™13 Proceedings, Genoa, Italy, March 18-22, 2013_ [, pages 81â€“92. ACM, 2013. doi:10.1145/2448496.2448508.](https://doi.org/10.1145/2448496.2448508)

[39] Arnaud Durand and Stefan Mengel. The complexity of weighted counting for acyclic conjunctive queries. _J. Comput._
_Syst. Sci._ [, 80(1):277â€“296, 2014. URL: https://doi.org/10.1016/j.jcss.2013.08.001, doi:10.1016/J.JCSS.2013.08.001.](https://doi.org/10.1016/j.jcss.2013.08.001)

[40] Friedrich Eisenbrand and Fabrizio Grandoni. On the complexity of fixed parameter clique and dominating set. _Theor._
_Comput. Sci._ [, 326(1-3):57â€“67, 2004. URL: https://doi.org/10.1016/j.tcs.2004.05.009,](https://doi.org/10.1016/j.tcs.2004.05.009) [doi:10.1016/J.TCS.2004.05.009](https://doi.org/10.1016/J.TCS.2004.05.009) .

[41] Austen Z. Fan, Paraschos Koutris, and Hangdong Zhao. The fine-grained complexity of boolean conjunctive queries
and sum-product problems. In Kousha Etessami, Uriel Feige, and Gabriele Puppis, editors, _50th International Colloquium_
_on Automata, Languages, and Programming, ICALP 2023, July 10-14, 2023, Paderborn, Germany_, volume 261 of _LIPIcs_,
[pages 127:1â€“127:20. Schloss Dagstuhl - Leibniz-Zentrum fÃ¼r Informatik, 2023. URL: https://doi.org/10.4230/LIPIcs.](https://doi.org/10.4230/LIPIcs.ICALP.2023.127)
[ICALP.2023.127, doi:10.4230/LIPICS.ICALP.2023.127.](https://doi.org/10.4230/LIPIcs.ICALP.2023.127)

[42] [Simons Institute for the Theory of Computing. Logic and algorithms in database theory and ai boot camp. https:](https://simons.berkeley.edu/workshops/logic-algorithms-database-theory-ai-boot-camp#simons-tabs)
[//simons.berkeley.edu/workshops/logic-algorithms-database-theory-ai-boot-camp#simons-tabs, August 2023.](https://simons.berkeley.edu/workshops/logic-algorithms-database-theory-ai-boot-camp#simons-tabs)




22 Stefan Mengel


[43] Anka Gajentaan and Mark H. Overmars. On a class of _ğ‘‚_ ( _ğ‘›_ [2] ) problems in computational geometry. _Comput. Geom._,
[5:165â€“185, 1995. doi:10.1016/0925-7721(95)00022-2.](https://doi.org/10.1016/0925-7721(95)00022-2)

[44] FranÃ§ois Le Gall. Faster algorithms for rectangular matrix multiplication. In _53rd Annual IEEE Symposium on_
_Foundations of Computer Science, FOCS 2012, New Brunswick, NJ, USA, October 20-23, 2012_, pages 514â€“523. IEEE
[Computer Society, 2012. doi:10.1109/FOCS.2012.80.](https://doi.org/10.1109/FOCS.2012.80)

[45] Etienne Grandjean and Louis Jachiet. Which arithmetic operations can be performed in constant time in the RAM
model with addition? _CoRR_ [, abs/2206.13851, 2022. URL: https://doi.org/10.48550/arXiv.2206.13851,](https://doi.org/10.48550/arXiv.2206.13851) [arXiv:2206.13851](https://arxiv.org/abs/2206.13851),
[doi:10.48550/ARXIV.2206.13851.](https://doi.org/10.48550/ARXIV.2206.13851)

[46] Gianluigi Greco and Francesco Scarcello. Counting solutions to conjunctive queries: structural and hybrid tractability.
In Richard Hull and Martin Grohe, editors, _Proceedings of the 33rd ACM SIGMOD-SIGACT-SIGART Symposium on_
_Principles of Database Systems, PODSâ€™14, Snowbird, UT, USA, June 22-27, 2014_, pages 132â€“143. ACM, 2014. [doi:](https://doi.org/10.1145/2594538.2594559)
[10.1145/2594538.2594559.](https://doi.org/10.1145/2594538.2594559)

[47] Martin Grohe. Parameterized complexity for the database theorist. _SIGMOD Rec._, 31(4):86â€“96, 2002. [doi:10.1145/](https://doi.org/10.1145/637411.637428)

[637411.637428.](https://doi.org/10.1145/637411.637428)

[48] Martin Grohe. The complexity of homomorphism and constraint satisfaction problems seen from the other side. _J._
_ACM_ [, 54(1):1:1â€“1:24, 2007. doi:10.1145/1206035.1206036.](https://doi.org/10.1145/1206035.1206036)

[49] Martin Grohe, Thomas Schwentick, and Luc Segoufin. When is the evaluation of conjunctive queries tractable? In
Jeffrey Scott Vitter, Paul G. Spirakis, and Mihalis Yannakakis, editors, _Proceedings on 33rd Annual ACM Symposium on_
_Theory of Computing, July 6-8, 2001, Heraklion, Crete, Greece_, pages 657â€“666. ACM, 2001. [doi:10.1145/380752.380867](https://doi.org/10.1145/380752.380867) .

[50] Xiao Hu. Fast matrix multiplication for query processing. _Proc. ACM Manag. Data_, 2(2):98, 2024. [doi:10.1145/3651599](https://doi.org/10.1145/3651599) .

[51] Russell Impagliazzo and Ramamohan Paturi. On the complexity of k-sat. _J. Comput. Syst. Sci._, 62(2):367â€“375, 2001.
[URL: https://doi.org/10.1006/jcss.2000.1727, doi:10.1006/JCSS.2000.1727.](https://doi.org/10.1006/jcss.2000.1727)

[52] Russell Impagliazzo, Ramamohan Paturi, and Francis Zane. Which problems have strongly exponential complexity? _J._
_Comput. Syst. Sci._ [, 63(4):512â€“530, 2001. URL: https://doi.org/10.1006/jcss.2001.1774, doi:10.1006/JCSS.2001.1774.](https://doi.org/10.1006/jcss.2001.1774)

[53] Ahmet Kara, Hung Q. Ngo, Milos Nikolic, Dan Olteanu, and Haozhe Zhang. Counting triangles under updates in
worst-case optimal time. In Pablo BarcelÃ³ and Marco Calautti, editors, _22nd International Conference on Database Theory,_
_ICDT 2019, March 26-28, 2019, Lisbon, Portugal_, volume 127 of _LIPIcs_, pages 4:1â€“4:18. Schloss Dagstuhl - Leibniz-Zentrum
[fÃ¼r Informatik, 2019. URL: https://doi.org/10.4230/LIPIcs.ICDT.2019.4, doi:10.4230/LIPICS.ICDT.2019.4.](https://doi.org/10.4230/LIPIcs.ICDT.2019.4)

[54] Ahmet Kara, Milos Nikolic, Dan Olteanu, and Haozhe Zhang. Trade-offs in static and dynamic evaluation of hierarchical
queries. In Dan Suciu, Yufei Tao, and Zhewei Wei, editors, _Proceedings of the 39th ACM SIGMOD-SIGACT-SIGAI_
_Symposium on Principles of Database Systems, PODS 2020, Portland, OR, USA, June 14-19, 2020_, pages 375â€“392. ACM,
[2020. doi:10.1145/3375395.3387646.](https://doi.org/10.1145/3375395.3387646)

[55] Ahmet Kara, Milos Nikolic, Dan Olteanu, and Haozhe Zhang. Conjunctive queries with free access patterns under
updates. In Floris Geerts and Brecht Vandevoort, editors, _26th International Conference on Database Theory, ICDT 2023,_
_March 28-31, 2023, Ioannina, Greece_, volume 255 of _LIPIcs_, pages 17:1â€“17:20. Schloss Dagstuhl - Leibniz-Zentrum fÃ¼r
[Informatik, 2023. URL: https://doi.org/10.4230/LIPIcs.ICDT.2023.17, doi:10.4230/LIPICS.ICDT.2023.17.](https://doi.org/10.4230/LIPIcs.ICDT.2023.17)

[56] Richard M. Karp. Reducibility among combinatorial problems. In Raymond E. Miller and James W. Thatcher, editors,
_Proceedings of a symposium on the Complexity of Computer Computations, held March 20-22, 1972, at the IBM Thomas J._
_Watson Research Center, Yorktown Heights, New York, USA_, The IBM Research Symposia Series, pages 85â€“103. Plenum
[Press, New York, 1972. doi:10.1007/978-1-4684-2001-2\_9.](https://doi.org/10.1007/978-1-4684-2001-2_9)

[57] Mahmoud Abo Khamis, Ryan R. Curtin, Benjamin Moseley, Hung Q. Ngo, XuanLong Nguyen, Dan Olteanu, and
Maximilian Schleich. Functional aggregate queries with additive inequalities. _ACM Trans. Database Syst._, 45(4):17:1â€“
[17:41, 2020. doi:10.1145/3426865.](https://doi.org/10.1145/3426865)

[58] Mahmoud Abo Khamis, Xiao Hu, and Dan Suciu. Fast matrix multiplication meets the subdmodular width. _CoRR_,
[abs/2412.06189, 2024. URL: https://doi.org/10.48550/arXiv.2412.06189,](https://doi.org/10.48550/arXiv.2412.06189) [arXiv:2412.06189](https://arxiv.org/abs/2412.06189), [doi:10.48550/ARXIV.](https://doi.org/10.48550/ARXIV.2412.06189)

[2412.06189.](https://doi.org/10.48550/ARXIV.2412.06189)

[59] Mahmoud Abo Khamis, Hung Q. Ngo, and Atri Rudra. FAQ: questions asked frequently. In Tova Milo and Wang-Chiew
Tan, editors, _Proceedings of the 35th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS_
_2016, San Francisco, CA, USA, June 26 - July 01, 2016_ [, pages 13â€“28. ACM, 2016. doi:10.1145/2902251.2902280.](https://doi.org/10.1145/2902251.2902280)

[60] Mahmoud Abo Khamis, Hung Q. Ngo, and Dan Suciu. What do shannon-type inequalities, submodular width, and
disjunctive datalog have to do with one another? In Emanuel Sallinger, Jan Van den Bussche, and Floris Geerts, editors,
_Proceedings of the 36th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS 2017, Chicago,_
_IL, USA, May 14-19, 2017_ [, pages 429â€“444. ACM, 2017. doi:10.1145/3034786.3056105.](https://doi.org/10.1145/3034786.3056105)

[61] Andrea Lincoln, Virginia Vassilevska Williams, and R. Ryan Williams. Tight hardness for shortest cycles and
paths in sparse graphs. In Artur Czumaj, editor, _Proceedings of the Twenty-Ninth Annual ACM-SIAM Symposium_
_on Discrete Algorithms, SODA 2018, New Orleans, LA, USA, January 7-10, 2018_, pages 1236â€“1252. SIAM, 2018. [doi:](https://doi.org/10.1137/1.9781611975031.80)
[10.1137/1.9781611975031.80.](https://doi.org/10.1137/1.9781611975031.80)




Lower Bounds for Conjunctive Query Evaluation 23


[62] DÃ¡niel Marx. Tractable hypergraph properties for constraint satisfaction and conjunctive queries. _J. ACM_, 60(6):42:1â€“
[42:51, 2013. doi:10.1145/2535926.](https://doi.org/10.1145/2535926)

[63] Stefan Mengel. A short note on the counting complexity of conjunctive queries. _CoRR_, abs/2112.01108, 2021. URL:
[https://arxiv.org/abs/2112.01108, arXiv:2112.01108.](https://arxiv.org/abs/2112.01108)

[64] Jaroslav NeÅ¡etÅ™il and Svatopluk Poljak. On the complexity of the subgraph problem. _Commentationes Mathematicae_
_Universitatis Carolinae_, 26(2):415â€“419, 1985.

[65] Hung Q. Ngo. Worst-case optimal join algorithms: Techniques, results, and open problems. In Jan Van den Bussche
and Marcelo Arenas, editors, _Proceedings of the 37th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database_
_Systems, Houston, TX, USA, June 10-15, 2018_ [, pages 111â€“124. ACM, 2018. doi:10.1145/3196959.3196990.](https://doi.org/10.1145/3196959.3196990)

[66] Hung Q. Ngo, Ely Porat, Christopher RÃ©, and Atri Rudra. Worst-case optimal join algorithms. _J. ACM_, 65(3):16:1â€“16:40,
[2018. doi:10.1145/3180143.](https://doi.org/10.1145/3180143)

[67] Dan Olteanu and Jakub ZÃ¡vodnÃ½. Size bounds for factorised representations of query results. _ACM Trans. Database_
_Syst._ [, 40(1):2:1â€“2:44, 2015. doi:10.1145/2656335.](https://doi.org/10.1145/2656335)

[68] Mihai PÄƒtraÅŸcu and Ryan Williams. On the possibility of faster SAT algorithms. In Moses Charikar, editor, _Proceedings_
_of the Twenty-First Annual ACM-SIAM Symposium on Discrete Algorithms, SODA 2010, Austin, Texas, USA, January_
_17-19, 2010_ [, pages 1065â€“1075. SIAM, 2010. doi:10.1137/1.9781611973075.86.](https://doi.org/10.1137/1.9781611973075.86)

[69] Reinhard Pichler and Sebastian Skritek. Tractable counting of the answers to conjunctive queries. _J. Comput. Syst. Sci._,
[79(6):984â€“1001, 2013. URL: https://doi.org/10.1016/j.jcss.2013.01.012, doi:10.1016/J.JCSS.2013.01.012.](https://doi.org/10.1016/j.jcss.2013.01.012)

[70] Luc Segoufin. A glimpse on constant delay enumeration (invited talk). In Ernst W. Mayr and Natacha Portier,
editors, _31st International Symposium on Theoretical Aspects of Computer Science (STACS 2014), STACS 2014, March 5-8,_
_2014, Lyon, France_, volume 25 of _LIPIcs_, pages 13â€“27. Schloss Dagstuhl - Leibniz-Zentrum fÃ¼r Informatik, 2014. URL:
[https://doi.org/10.4230/LIPIcs.STACS.2014.13, doi:10.4230/LIPICS.STACS.2014.13.](https://doi.org/10.4230/LIPIcs.STACS.2014.13)

[71] Luc Segoufin. Constant delay enumeration for conjunctive queries. _SIGMOD Rec._, 44(1):10â€“17, 2015. [doi:10.1145/](https://doi.org/10.1145/2783888.2783894)

[2783888.2783894.](https://doi.org/10.1145/2783888.2783894)

[72] Volker Strassen. Gaussian elimination is not optimal. _Numerische mathematik_, 13(4):354â€“356, 1969.

[73] Nikolaos Tziavelis, Deepak Ajwani, Wolfgang Gatterbauer, Mirek Riedewald, and Xiaofeng Yang. Optimal algorithms
for ranked enumeration of answers to full conjunctive queries. _Proc. VLDB Endow._, 13(9):1582â€“1597, 2020. URL:
[http://www.vldb.org/pvldb/vol13/p1582-tziavelis.pdf, doi:10.14778/3397230.3397250.](http://www.vldb.org/pvldb/vol13/p1582-tziavelis.pdf)

[74] Leslie G. Valiant. General context-free recognition in less than cubic time. _J. Comput. Syst. Sci._, 10(2):308â€“315, 1975.
[doi:10.1016/S0022-0000(75)80046-8.](https://doi.org/10.1016/S0022-0000(75)80046-8)

[75] Moshe Y. Vardi. The complexity of relational query languages (extended abstract). In Harry R. Lewis, Barbara B. Simons,
Walter A. Burkhard, and Lawrence H. Landweber, editors, _Proceedings of the 14th Annual ACM Symposium on Theory of_
_Computing, May 5-7, 1982, San Francisco, California, USA_, pages 137â€“146. ACM, 1982. [doi:10.1145/800070.802186](https://doi.org/10.1145/800070.802186) .

[76] Virginia Vassilevska Williams and R. Ryan Williams. Subcubic equivalences between path, matrix, and triangle
problems. _J. ACM_ [, 65(5):27:1â€“27:38, 2018. doi:10.1145/3186893.](https://doi.org/10.1145/3186893)

[77] Virginia Vassilevska Williams and Ryan Williams. Finding, minimizing, and counting weighted subgraphs. _SIAM J._
_Comput._ [, 42(3):831â€“854, 2013. doi:10.1137/09076619X.](https://doi.org/10.1137/09076619X)

[78] Virginia Vassilevska Williams. On some fine-grained questions in algorithms and complexity. In _Proceedings of the_
_international congress of mathematicians: Rio de janeiro 2018_, pages 3447â€“3487. World Scientific, 2018.

[79] Mihalis Yannakakis. Algorithms for acyclic database schemes. In _Very Large Data Bases, 7th International Conference,_
_September 9-11, 1981, Cannes, France, Proceedings_, pages 82â€“94. IEEE Computer Society, 1981.

[80] Raphael Yuster and Uri Zwick. Detecting short directed cycles using rectangular matrix multiplication and dynamic
programming. In J. Ian Munro, editor, _Proceedings of the Fifteenth Annual ACM-SIAM Symposium on Discrete Algorithms,_
_SODA 2004, New Orleans, Louisiana, USA, January 11-14, 2004_ [, pages 254â€“260. SIAM, 2004. URL: http://dl.acm.org/](http://dl.acm.org/citation.cfm?id=982792.982828)
[citation.cfm?id=982792.982828.](http://dl.acm.org/citation.cfm?id=982792.982828)

[81] Hangdong Zhao, Shaleen Deep, and Paraschos Koutris. Space-time tradeoffs for conjunctive queries with access
patterns. In Floris Geerts, Hung Q. Ngo, and Stavros Sintos, editors, _Proceedings of the 42nd ACM SIGMOD-SIGACT-_
_SIGAI Symposium on Principles of Database Systems, PODS 2023, Seattle, WA, USA, June 18-23, 2023_, pages 59â€“68. ACM,
[2023. doi:10.1145/3584372.3588675.](https://doi.org/10.1145/3584372.3588675)

[82] Hangdong Zhao, Austen Z. Fan, Xiating Ouyang, and Paraschos Koutris. Conjunctive queries with negation and
aggregation: A linear time characterization. _Proc. ACM Manag. Data_ [, 2(2):75, 2024. doi:10.1145/3651138.](https://doi.org/10.1145/3651138)


